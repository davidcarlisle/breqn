\NeedsTeXFormat{LaTeX2e}[1995/06/01]
\errorcontextlines=99 % show more context
% Percent char is not a comment char any more after this point !!
\input{lls.deh}
(document
  filename=breqn.lls
  version=0.9 2000-01-13


(styleelement=figure
(frame(width.2pt<width)<frame)
<style)

(prolog
(titleThe (pkgbreqn<pkg) package --- beta version, 1999/12/20<title)
(authorMichael Downes<author)
(dateAmerican Mathematical Society<date)
<prolog)

(section(titleintroduction<title)
(para(.the (pkgbreqn<pkg) package provides environments
(envdmath<env), (envdseries<env), and (envdgroup<env) for
displayed equations with (emphautomatic line breaking<emph),
including automatic indention of relation symbols and binary operator
symbols at the beginning of broken lines<.) (.these environments
automatically pull in following punctuation so that it can be written in
a natural way<.) (.the (pkgbreqn<pkg) package also provides a
(envdarray<env) environment similar to the (envarray<env)
environment but using (csdisplaystyle<cs) for all the array cells and
providing better interline spacing (pbecause the vertical ruling
feature of (envarray<env) is dropped<p)<.)
(.these are all autonumbered environments like (envequation<env)
and have starred forms that don't add a number<.) (.for a more
comprehensive and detailed description of the features and intended
usage of the (pkgbreqn<pkg) package see (fnbreqndoc.tex<fn)<.)
<para)
<section)

(section(titlestrategy<title)
(para(.features of particular note are the ability to have
linebreaks even within a (csleft<cs) [ndash] (csright<cs) pair of
delimiters, and the automatic alignment on relations and binary
operators of a split equation<.) (.to make (envdmath<env) handle
all this, we begin by setting the body of the equation in a special
paragraph form with strategic line breaks whose purpose is not to
produce line breaks in the final printed output but rather to mark
significant points in the equation and give us entry points for
unpacking (cnleft<cn) [ndash] (cnright<cn) boxes<.)
(.after the initial typesetting, we take the resulting stack of line
fragments and, working backward, splice them into a new, single-line
paragraph; this will eventually be poured into a custom parshape, after
we do some measuring to calculate what that parshape should be<.)
(.this streamlined horizontal list may contain embedded material
from user commands intended to alter line breaks, horizontal alignment,
and interline spacing; such material requires special handling<.)
<para)
(para(.to make the (qshortskip<q) possibility work even for
multiline equations, we must plug in a dummy [tex] display to give us
the value of (cspredisplaysize<cs), and calculate for ourselves when
to apply the short skips<.)
<para)
(para(.in order to measure the equation body and do various
enervating calculations on whether the equation number will fit and so
on, we have to set it in a box<.) (.among other things, this means
that we can't unhbox it inside [dbldollars] [dots] [dbldollars], or
even (qc$<qc) [dots] (qc$<qc): [tex] doesn't allow you to
(csunhbox<cs) in math mode<.) (.but we do want to unhbox it rather
than just call (csbox<cs), otherwise we can't take advantage of
available shrink from (csmedmuskip<cs) to make equations shrink to
fit in the available width<.) (.so even for simple one-line equations
we are forced to fake a whole display without going through [tex]'s
primitive display mechanism (pexcept for using it to get
(cspredisplaysize<cs) as mentioned above<p)<.)
<para)
(para
(.in the case of a framed equation body, the current implementation is
to set the frame in a separate box, of width zero and height zero,
pinned to the upper left corner of the equation body, and then print the
equation body on top of it<.)
(.for attaching an equation number it would be much simpler to wrap
the equation body in the frame and from then on treat the body as a
single box instead of multiple line boxes<.)
(.but I had a notion that it might be possible some day to support
vertical stretching of the frame<.)
<para)
<section)

(section(titleprelim<title)
(para(.this package doesn't work with [latex] 2.09, nor with other
versions of [latex] earlier than 1994/12/01<.)
(code
\NeedsTeXFormat{LaTeX2e}[1994/12/01]
<code)
<para)
(para(.declare package name and date<.)
(code
\ProvidesPackage{breqn}[2000/01/13 v0.9 alpha]
<code)
<para)
<section)

(section(titlepatches<title)
(para(.For a version of [latex] older than 1995/06/01, we need to remove
outer-ness from (csnewif<cs), (csnewtoks<cs), and (csnewif<cs)<.)
(p(.using (cs@namedef<cs) instead of (csdef<cs) to prevent
the usual outer-ness troubles<.)<p)
(code
\@ifl@t@r\fmtversion{1995/06/01}{}{%
  \@namedef{newmuskip}{\alloc@3\muskip\muskipdef\@cclvi}%
  \@namedef{newtoks}{\alloc@5\toks\toksdef\@cclvi}%
  \@namedef{newif}#1{\count@\escapechar \escapechar\m@ne
      \let#1\iffalse \@if#1\iftrue \@if#1\iffalse \escapechar\count@}%
}
<code)
<para)
<section)

(section(titlepackage options<title)
(para
(.most options are set with the (csoptions<cs) command (pwhich
calls (cssetkeys<cs)<p) because the standard package option
mechanism doesn't provide support for key-value syntax<.)
(.cf (fnbreqndoc.tex<fn)<.)
<para)
(para(.it seems easier to turn off debugging than turn it on so the
implementation of the (optdebug<opt) option is sort of backward<.)
(code
\DeclareOption{debug}{}
<code)
(.process options<.)
(code
\ProcessOptions\relax
<code)
<para)
<section)

(section(titlerequired packages<title)
(para(.the (pkgflexisym<pkg) package makes it possible to attach
extra actions to math symbols, in particular mathbin, mathrel, mathopen,
and mathclose symbols<.)
(.normally it would suffice to call (csRequirePackage<cs) without
any extra testing, but the nature of the package is such that it is
likely to be called earlier with different (pno<p) options<.)
(?then is it really helpful to be always warning the user about
(qIncompatible Package Options!<q)<?)
(.I don't think so<.)
(code
\@ifpackageloaded{flexisym}{}{%
  \RequirePackage[cmbase]{flexisym}[1997/01/01]
}
<code)
(.The (pkgkeyval<pkg) package for handling equation options<.)
(code
\RequirePackage{keyval}\relax
<code)
<para)

(para(.and add an (csoptions<cs) cmd for processing package
options that require an argument<.) (.maybe this will get added to
the (pkgkeyval<pkg) package eventually<.)
(code
\@ifundefined{options}{%
<code)
<para)

(define(cmdoptions<cmd)
(para(.get the package options and run setkeys on them<.)
(code
\newcommand{\options}[2]{%
  \expandafter\options@a\csname opt@#1.sty\endcsname{#2}%
  \setkeys{#1}{#2}%
}
<code)
<para)<define)

(define(macrooptions@a<macro)
(macrooptions@b<macro)
(macrooptions@c<macro)
(macrooptions@d<macro)
(para(.redefine (csopt@pkgname.sty<cs) as we go along to take out
the options that are handled and leave the ones that are not<.)
(code
\def\options@a#1#2{%
  \edef\@tempa{\options@b#2,\@empty\@nil}%
  \ifx#1\relax \let#1\@empty\fi
  \xdef#1{#1\ifx#1\@empty\@xp\@gobble\@tempa\@empty\else\@tempa \fi}%
}
<code)
(.add the next option, and recurse if there remain more
options<.)
(code
\def\options@b#1,#2#3\@nil{%
  \options@c#1 \@nil
  \ifx#2\@empty \else\options@b#2#3\@nil\fi
}
<code)
(.discard everything after the first space<.)
(code
\def\options@c#1 #2\@nil{\options@d#1=\@nil}
<code)
(.discard everything after the first = sign; add a comma only if the
remainder is not empty<.)
(code
\def\options@d#1=#2\@nil{\ifx\@empty #1\@empty\else,\fi#1}
<code)
<para)<define)

(para
(.the tail of the (cs@ifundefined<cs) test<.)
(code
}{}% end @ifundefined test
<code)
<para)
<section)

(section(titlesome useful tools<title)

(define(macro@nx<macro)
(macro@xp<macro)
(para(.the comparative brevity of (cs@nx<cs) and (cs@xp<cs) is
valuable not so much for typing convenience as for reducing visual
clutter in code sections that require a lot of expansion control<.)
(code
\let\@nx\noexpand
\let\@xp\expandafter
<code)
<para)<define)

(define(toks@emptytoks<toks)
(para(.constant empty token register, analogous to (cs@empty<cs)<.)
(code
\@ifundefined{@emptytoks}{\newtoks\@emptytoks}{}
<code)
<para)<define)

(define(constf@ur<const)
(para(.constants 0[ndash]3 are provided in plain [tex], but not 4<.)
(code
\chardef\f@ur=4
<code)
<para)<define)

(define(constinf@bad<const)
(para(.(csinf@bad<cs) is for testing box badness<.)
(code
\newcount\inf@bad \inf@bad=1000000
<code)
<para)<define)

(define(macromaxint<macro)
(para
(.we want to use (csmaxint<cs) rather than coerced
(csmaxdimen<cs) for (cslinepenalty<cs) in one place<.)
(code
\newcount\maxint \maxint=2147483647
<code)
<para)
<define)

(define(macroint@a<macro)
(macroint@b<macro)
(macroint@b<macro)
(para
(.provide some shorter aliases for various scratch registers<.)
(code
\let\int@a=\@tempcnta
\let\int@b=\@tempcntb
\let\int@c=\count@
<code)
<para)
<define)

(define(macrodim@a<macro)
(macrodim@b<macro)
(macrodim@c<macro)
(macrodim@d<macro)
(macrodim@e<macro)
(macrodim@A<macro)
(para
(.same for dimen registers<.)
(code
\let\dim@a\@tempdima
\let\dim@b\@tempdimb
\let\dim@c\@tempdimc
\let\dim@d\dimen@
\let\dim@e\dimen@ii
\let\dim@A\dimen@i
<code)
<para)
<define)

(define(macroskip@a<macro)
(macroskip@b<macro)
(macroskip@c<macro)
(para
(.same for skip registers<.)
(code
\let\skip@a\@tempskipa
\let\skip@b\@tempskipb
\let\skip@c\skip@
<code)
<para)
<define)

(define(macrotoks@a<macro)
(macrotoks@b<macro)
(macrotoks@c<macro)
(macrotoks@d<macro)
(macrotoks@e<macro)
(macrotoks@f<macro)
(para
(.same for token registers<.)
(code
\let\toks@a\@temptokena
\let\toks@b\toks@
\toksdef\toks@c=2
\toksdef\toks@d=4
\toksdef\toks@e=6
\toksdef\toks@f=8
<code)
<para)
<define)

(define(macroabs@num<macro)
(para(.we need an absolute value function for comparing
penalties<.)
(code
\def\abs@num#1{\ifnum#1<\z@-\fi#1}
<code)
<para)<define)

(define(macro@ifnext<macro)
(macro@ifnexta<macro)
(para(.the (cs@ifnext<cs) function is a variation of
(cs@ifnextchar<cs) that doesn't skip over intervening whitespace<.)
(.we use it for the optional arg of [dbslash] inside
(envdmath<env) [etc] because we don't want
unwary users to be tripped up by an unexpected attempt on [latex]'s part
to interpret a bit of math as an optional arg:
(literal
\begin{equation}
...\\
[z,w]...
<literal)
<.)
(code
\def\@ifnext#1#2#3{%
  \let\@tempd= #1\def\@tempa{#2}\def\@tempb{#3}%
  \futurelet\@tempc\@ifnexta
}
<code)
(.switch to (cs@tempa<cs) iff the next token matches<.)
(code
\def\@ifnexta{\ifx\@tempc\@tempd \let\@tempb\@tempa \fi \@tempb}
<code)
<para)
<define)

(define(macro@ifstar<macro)
(para(.similarly let's remove space-skipping from (cs@ifstar<cs)
because in some rare case of [dbslash] inside an equation, followed by
a space and a (qc*<qc) where the (qc*<qc) is intended as the math
binary operator, it would be a disservice to gobble the star as an
option of the [dbslash] command<.) (.in all other contexts the chance
of having a space (emphbefore<emph) the star is extremely small: either
the command is a control word which will get no space token after it in
any case because of [tex]'s tokenization rules; or it is a control
symbol such as [dbslash] (qc*<qc) which is exceedingly unlikely to be
written as [dbslash] (qc*<qc) by any one who really wants the
(qc*<qc) to act as a modifier for the [dbslash] command<.)
(code
\def\@ifstar#1#2{%
  \let\@tempd*\def\@tempa*{#1}\def\@tempb{#2}%
  \futurelet\@tempc\@ifnexta
}
<code)
<para)<define)

(define(macro@optarg<macro)
(para(.utility function for reading an optional arg
(emphwithout<emph) skipping over any intervening spaces<.)
(code
\def\@optarg#1#2{\@ifnext[{#1}{#1[#2]}}
<code)
<para)
<define)

(define(macro@True<macro)
(macro@False<macro)
(macro@Not<macro)
(macro@And<macro)
(para(.after ("\let\foo\@True<") the test
(literal
\if\foo
<literal)
evaluates to true<.) (.would rather avoid (csnewif<cs) because it
uses three csnames per Boolean variable; this uses only one<.)
(code
\def\@True{00}
\def\@False{01}
\def\@Not#1{0\ifcase#11 \or\@xp 1\else \@xp 0\fi}
\def\@And#1#2{0\ifcase#1#2 \@xp 0\else \@xp 1\fi}
\def\@Or#1#2{0\ifnum#1#2<101 \@xp 0\else \@xp 1\fi}
<code)
<para)<define)

(define(macrofreeze@glue<macro)
(para
(.remove the stretch and shrink from a glue register<.)
(code
\def\freeze@glue#1{#11#1\relax}
<code)
<para)
<define)

(define(macroz@rule<macro)
(macrokeep@glue<macro)
(para(.note well
the intentional absence of (csrelax<cs) at the end of the replacement
text of (csz@rule<cs); use it with care<.)
(code
\def\z@rule{\vrule\@width\z@}% no \relax ! use with care
<code)
(.different ways to keep a bit of glue from disappearing at the
beginning of a line after line breaking:
(itemize
(item(fragZero-thickness rule<frag)
<item)
(item(fragNull character<frag)
<item)
(item(frag(csvadjust<cs)(c{}<c) (p[texbook], Exercise ??<p)<frag)
<item)
<itemize) <.) (.the null character idea would be nice except it
creates a mathord which then screws up math spacing for [eg] a following
unary minus sign<.) (.(pthe vrule (emphis<emph) transparent to
the math spacing<p)<.) (.the vadjust is the cheapest in terms of box
memory[mdash]it vanishes after the pass through [tex]'s
paragrapher<.)
(.it is what I would have used, except that the equation contents get
run through two paragraphing passes, once for breaking up LR boxes and
once for the real typesetting<.)
(.if (cskeep@glue<cs) were done with an empty vadjust, it would
disappear after the first pass and[mdash]in particular[mdash]the
pre-bin-op adjustment for relation symbols would disappear at a line break<.)
(code
\def\keep@glue{\z@rule\relax}
<code)
<para)<define)

(define(macroreplicate<macro)
(para
(.this is a fully expandable way of making N copies of a token
list<.)
(.based on a post of David Kastrup to comp.text.tex circa January
1999<.)
(.the extra application of (csnumber<cs) is needed for maximal
robustness in case the repeat count N is given in some weird [tex] form
such as (""E9<") or ("\count9<")<.)
(code
% usage: \message{H\replicate{5}{i h}ow de doo dee!}
\begingroup \catcode`\&=11
\gdef\replicate#1{%
  \csname &\expandafter\replicate@a\romannumeral\number\number#1 000q\endcsname
}
\endgroup
<code)
<para)
<define)

(define(macroreplicate@a<macro)
(para
(code
\long\def\replicate@a#1#2\endcsname#3{#1\endcsname{#3}#2}
<code)
<para)
<define)

(define(macro&m<macro)
(para
(code
\begingroup \catcode`\&=11
\long\gdef\&m#1#2{#1\csname &#2\endcsname{#1}}
\endgroup
<code)
<para)
<define)

(define(macro&q<macro)
(para
(code
\@xp\let\csname\string &q\endcsname\@gobble
<code)
<para)
<define)

(define(macromathchars@reset<macro)
(para
(.need to patch up this function from flexisym a little, to better
handle certain constructed symbols like (csneq<cs)<.)
(code
\g@addto@macro\mathchars@reset{%
  \let\@symRel\@secondoftwo \let\@symBin\@secondoftwo
  \let\@symDeL\@secondoftwo \let\@symDeR\@secondoftwo
  \let\@symDeB\@secondoftwo
}
<code)
<para)
<define)

(define(macroeq@cons<macro)
(para
(.[latex]'s (cs@cons<cs) appends to the end of a list, but we need
a function that adds material at the beginning<.)
(code
\def\eq@cons#1#2{%
  \begingroup \let\@elt\relax \xdef#1{\@elt{#2}#1}\endgroup
}
<code)
<para)
<define)

(define(macro@saveprimitive<macro)
(para(.if some preceding package redefined one of the
primitives that we must change, we had better do some checking to make
sure that we are able to save the primitive meaning for internal use<.)
(.this is handled by the (cs@saveprimitive<cs) function<.) (.we
follow the example of (cs@@input<cs) where the primitive meaning is
stored in an internal control sequence with a (ttq@@<ttq) prefix<.)
(.primitive control sequences can be distinguished by the fact that
(csstring<cs) and (csmeaning<cs) return the same information<.)
(.well, not quite all: (csnullfont<cs) and (cstopmark<cs)
and the other (cs...mark<cs) primitives being the exceptions<.)
(code
\providecommand{\@saveprimitive}[2]{%
  \begingroup
  \edef\@tempa{\string#1}\edef\@tempb{\meaning#1}%
  \ifx\@tempa\@tempb \global\let#2#1%
  \else
<code)%
(.if [arg1] is no longer primitive, then we are in trouble unless
[arg2] was already given the desired primitive meaning somewhere
else<.)
(code
    \edef\@tempb{\meaning#2}%
    \ifx\@tempa\@tempb
    \else \@saveprimitive@a#1#2%
    \fi
  \fi
  \endgroup
}
<code)
(.aux function, check for the special cases<.)
(.most of the time this branch will be skipped so we can
stuff a lot of work into it without worrying about speed costs<.)
(code
\def\@saveprimitive@a#1#2{%
  \begingroup
  \def\@tempb##1#1##2{\edef\@tempb{##2}\@car{}}%
  \@tempb\nullfont{select font nullfont}%
    \topmark{\string\topmark:}%
    \firstmark{\string\firstmark:}%
    \botmark{\string\botmark:}%
    \splitfirstmark{\string\splitfirstmark:}%
    \splitbotmark{\string\splitbotmark:}%
    #1{\string#1}%
  \edef\@tempa{\expandafter\strip@prefix\meaning\@tempb}%
  \edef\@tempb{\meaning#1}%
  \ifx\@tempa\@tempb \global\let#2#1%
  \else
    \PackageError{breqn}%
      {Unable to properly define \string#2; primitive
      \noexpand#1no longer primitive}\@eha
    \fi
  \fi
  \endgroup
}
<code)
<para)<define)

(define(macro@@math<macro)
(macro@@endmath<macro)
(macro@@display<macro)
(macro@@enddisplay<macro)
(para(.move the math-start and math-end functions into control
sequences<.) (.if I were redesigning [tex] I guess I'd put these
functions into primitive control words instead of linking them to a
catcode<.) (.that way [tex] would not have to do the special
lookahead at a (qc$<qc) to see if there's another one coming up<.)
(.of course that's related to the question of how to provide user
shorthand for common constructions: [tex], or an editing interface of
some sort<.)
(code
\begingroup \catcode`\$=3 % just to make sure
  \global\let\@@math=$ \gdef\@@display{$$}
\endgroup
\let\@@endmath=\@@math
\let\@@enddisplay=\@@display
<code)
<para)<define)

(define(macro@@insert<macro)
(macro@@mark<macro)
(macro@@vadjust<macro)
(para(.save the primitives (csvadjust<cs), (csinsert<cs),
(csmark<cs) because we will want to change them locally during
equation measuring to keep them from getting in the way of our vertical
decomposition procedures<.) (.we follow the example of
(cs@@input<cs), (cs@@end<cs), (cs@@par<cs) where the primitive
meaning is stored in an internal control sequence with a (ttq@@<ttq)
prefix<.)
(code
\@saveprimitive\vadjust\@@vadjust
\@saveprimitive\insert\@@insert
\@saveprimitive\mark\@@mark
<code)
<para)<define)
<section)

(section(titledebugging<title)
(para(.debugging help<.)
<para)

(define(macrodebug<macro)
(para
(code
\let\debug=\begingroup
<code)
<para)
<define)

(define(macrogubed<macro)
(para
(code
\let\gubed=\endgroup
<code)
<para)
<define)

(define(macrodebugmsg<macro)
(para(.print a debugging message<.)
(code
\def\debugmsg{\message{||= \iffalse}\fi
  \@xp\@gobble\string
}
<code)
<para)
<define)

(define(macrodebugwr<macro)
(para
(.sometimes the newline behavior of (csmessage<cs) is
unsatisfactory; this provides an alternative<.)
(code
\def\debugwr#1{\immediate\write\sixt@@n{||= #1}}
<code)
<para)
<define)

(define(macrodebug@box<macro)
(para
(.record the contents of a box in the log file, without stopping<.)
(code
\def\debug@box#1{%
  \batchmode{\showboxbreadth\maxdimen\showboxdepth99\showbox#1}%
  \errorstopmode
}
<code)
<para)
<define)

(define(macroeqinfo<macro)
(para
(.show lots of info about the material before launching into the
trials<.)
(code
\def\eqinfo{%
  \debug@box\EQ@copy
  \wlog{!! EQ@copy: \the\wd\EQ@copy\space x
    \the\ht\EQ@copy+\the\dp\EQ@copy
  }%
}
<code)
<para)
<define)

(define(macrodebug@para<macro)
(para
(.check params that affect line breaking<.)
(code
\def\debug@para{%
  \debugwr{\hsize\the\hsize, \parfillskip\the\parfillskip}%
  \debugmsg{\leftskip\the\leftskip, \rightskip\the\rightskip}%
  \debugmsg{\linepenalty\the\linepenalty, \adjdemerits\the\adjdemerits}%
  \debugmsg{\pretolerance\the\pretolerance, \tolerance\the\tolerance,
    \parindent\the\parindent}%
}
<code)
<para)
<define)

(para(.turn off debugging unless it was asked for<.)
(code
\@ifpackagewith{breqn}{debug}{}{%
  \let\debug\relax \let\gubed\relax
  \let\debugmsg\@gobble \let\debug@lines\relax \let\debug@para\relax
  \let\debugwr\@gobble
  \let\debug@box\@gobble \let\debug@push\@gobbletwo
}
<code)
<para)
<section)

(section(titlethe (cslistwidth<cs) variable<title)
(para(.The dimen variable (cslistwidth<cs) is (cslinewidth<cs)
plus (csleftmargin<cs) plus (csrightmargin<cs), which is typically
less than (cshsize<cs) if the list depth is greater than one<.)
(.in case a future package will provide this variable, define it only
if not yet defined<.)
(code
\@ifundefined{listwidth}{\newdimen\listwidth}{}
\listwidth=\z@
<code)
<para)
<section)

(section(titleparameters<title)
(para(.a stunning cornucopia of them, in fact<.) (.I wanted to make a
table but a purely documentary table would be highly redundant with the
following code section and didn't strike me as wise maintenance policy,
so instead I formatted the source code itself into a crude table and
made a helper function to make more room for comments on each line<.)
<para)

(define(macroeqfontsize<macro)
(macroeqcolor<macro)
(macroeqmargin<macro)
(macroeqindent<macro)
(macroeqbinoffset<macro)
(macroeqnumside<macro)
(macroeqnumplace<macro)
(macroeqnumsep<macro)
(macroeqnumfont<macro)
(macroeqnumform<macro)
(macroeqnumsize<macro)
(macroeqnumcolor<macro)
(macroeqlinespacing<macro)
(macroeqlineskip<macro)
(macroeqlineskiplimit<macro)
(macroeqstyle<macro)
(macroeqinterlinepenalty<macro)
(macrointereqpenalty<macro)
(macrointereqskip<macro)
(para
(.note: avoid M, m, P, p because they look like they might be the
start of a keyword (qminus<q) or (qplus<q)<.) (.then
[tex] looks further to see if the next letter is i or l<.) (.and if
the next thing is an undefined macro, the attempt to expand the macro
results in an error message<.)
(code
\def\do#1#2{\begingroup
  \def\?##1#1##2##3##4##5\@nil{\endgroup##2##3\afterassignment\do##4}%
  \?C\newcount#2#2D\newdimen#2#2S\newskip#2#2U\newmuskip#2#2%
    K\newtoks#2#2F\newif#2{\z@\z@}T\newif#2{\let#2\iftrue}%
    B\newbox#2{\z@\z@}d{\newcommand#2{}}{}{\def#2}%
    Q\relax\@gobbletwo\relax \@nil}%
\do % def, Count, Dimen, Skip, mUskip, toKs, Box, False, True
d\eqfontsize{}         % Inherit from context
d\eqcolor{black}       % Default to black
D\eqnumsep=10pt        % Min space between equ number and body
D\eqmargin=8pt         % For `multline' gap emulation
<code)
(.the (cseqindent<cs) and (cseqnumside<cs) variables need to
have their values initialized from context, actually<.) (.but
that takes a bit of work, which is postponed till later<.)
(code
d\eqindent{C}%         % C or I, centered or indented
d\eqnumside{R}%        % R or L, right or left
d\eqnumplace{M}%       % M or T or B, middle top or bottom
<code)
(.typesetting the equation number is done thus:
(literal
{\eqnumcolor \eqnumsize \eqnumfont{\eqnumform{\eq@number}}}
<literal)
<.)
(code
%d\eqnumfont{\upshape}% % Upright even when surrounding text is slanted
d\eqnumfont{}%         % Null for easier debugging [mjd,1997/09/26]
d\eqnumform#1{(#1\@@italiccorr)} % Add parens
d\eqnumsize{}          % Allow numbers to have different typesize ...
<code)
(.tricky questions on (cseqnumsize<cs)<.) (?should the default
be (csnormalsize<cs)<?) (.then the user can scale down the
equation body with (cssmall<cs) and not affect the equation
number<.) (?or should the default be empty<?) (.then in large
sections of smaller text, like the dangerous bend stuff in
(emph[tex]book<emph), the equation number size will keep in synch
with the context<.)
(.maybe need an (cseqbodysize<cs) param as well to allow separating
the two cases<.)
(code
d\eqnumcolor{}         % ... or color than eq body e.g. \color{blue}
S\eqlinespacing=14pt plus2pt % Base-to-base space between lines
S\eqlineskip=3pt plus2pt % Min space if eqlinespacing too small
D\eqlineskiplimit=2pt  % Threshold for switching to eqlineskip
<code)
(.the value of (cseqbinoffset<cs) should include a negative shrink
component that cancels the shrink component of medmuskip, otherwise
there can be a noticeable variation in the indent of adjacent lines if
one is shrunken a lot and the other isn't<.)
(code
U\eqbinoffset=15mu minus-3mu % Offset from mathrel alignment pt for mathbins
U\eqdelimoffset=2mu    % Additional offset for break inside delims
D\eqindentstep=8pt     % Indent used when LHS wd is n/a or too large
K\eqstyle={}           % Customization hook
C\eqbreakdepth=2       % Allow breaks within delimiters to this depth
C\eqinterlinepenalty=10000 % No page breaks between equation lines
C\intereqpenalty=\@M   % Pagebreak penalty between equations
S\intereqskip=3pt plus2pt % Additional vert space between equations
C\prerelpenalty=-\@M   % Linebreak penalty before mathrel symbols
C\prebinoppenalty=888  % Linebreak penalty before mathbins
<code)
(.when breaking equations we never right-justify, so a stretch
component of the muskip is never helpful and sometimes it is definitely
undesirable<.) (.note that thick[slash]medmuskips frozen inside a
fraction or radical may turn out noticeably larger than neighboring
unfrozen ones<.) (.nonetheless I think this way is the best
compromise short of a new [tex] that can make those built-up objects
shrink horizontally in proportion; the alternative is to pretty much
eliminate the shrink possibility completely in displays<.)
(code
U\Dmedmuskip=4mu minus 3mu % medmuskip in displays
U\Dthickmuskip=5mu minus 2mu % thickmuskip in displays
Q\relax                % End of assignments
<code)
<para)
<define)
(para(.and now some internal variables<.) (.1997/10/22: some of
these are dead branches that need to be pruned<.)
(code
\do % def, Dimen, Skip, mUskip, toKs, Box, False, True
d\eq@number{}          % Internal variable
S\eqleftskip=\@centering  % Space on the left
S\eqrightskip=\@centering % Space on the right
S\eq@vspan=\z@skip     % Glue used to vcenter the eq number
U\eq@binoffset=\eqbinoffset % Roughly, \eqbinoffset + \eqdelimoffset
B\EQ@box               % Storage for equation body
B\EQ@copy              % For eq body sans vadjust/insert/mark material
B\EQ@numbox            % For equation number
%%B\EQ@vimbox            % Vadjust, insert, or mark material
%%B\EQ@vimcopy           % Spare copy of same
%%B\eq@impinging         % Temporary box for measuring number placement
T\if@eq@number         % Number present or not?
C\eq@lines=\z@         % Internal counter, actual number of lines
C\eq@curline=\z@       % Loop counter
C\eq@badness=\z@       % Used in testing for overfull lines
C\EQ@vims=\z@          % For bookkeeping
Q\relax
<code)
(.here for the dimens, it would be advisable to do some more careful
management to conserve dimen registers<.) (.first of all, most of the
dimen registers are needed in the measuring phase, which is a tightly
contained step that happens after the contents of the equation have been
typeset into a box and before any external functions have a chance to
regain control[mdash] [eg], the output routine<.)
(.therefore it is possible to make use of the the dimen registers 0--9,
reserved by convention for scratch use, without fear of conflict with
other macros<.) (.but I don't want to use them directly with the
available names:
(literal
\dimen@ \dimen@i \dimen@ii \dimen3 \dimen4 ... \dimen9
<literal)
<.) (.it would be much more useful to have names for these registers
indicative of way they are used<.)
<para)
(para(.another source whence dimen registers could be borrowed is the
(pkgamsmath<pkg) package, which allocates six registers for
equation-measuring purposes<.) (.we can reuse them under different
names since the (pkgamsmath<pkg) functions and our functions will
never be used simultaneously<.)
(literal
\eqnshift@ \alignsep@ \tagshift@ \tagwidth@ \totwidth@ \lineht@
<literal)
(code
\newdimen\eq@dp \newdimen\eq@sidespace
\newdimen\eq@wdL \newdimen\grp@wdL \newdimen\grp@wdT
\newdimen\eq@wdT \newdimen\eq@wdRmax \newdimen\eq@firstht
\newdimen\eq@indentstep \newdimen\eq@linewidth \newdimen\eq@freewidth
\newdimen\grp@linewidth
<code)
(.maybe (cseq@hshift<cs) could share the same register as
(csmathindent<cs) [mjd,1997/10/22]<.)
(code
\newdimen\eq@hshift
<code)
(.these are scratch variables, they get reset in every equation; so we
don't need to provide initialization values here<.)
(code
\def\do#1#2{\if Q#1\relax \else\@xp\do\fi}\do
D\eq@wdT        % Total width for framing
D\eq@wdL        % Width of the left-hand-side
D\eq@sidespace  % Min leftover space for centering
D\grp@wdL       % Max width of LHS's in a group
D\grp@wdT       % Max width of all equations in a group
D\eq@firstht    % Height of first line
D\eq@dp         % Depth of last line
D\eq@indentstep % Indent amount when LHS is not present
D\eq@linewidth  % Width actually used for display
D\grp@linewidth % Max eq@linewidth over a group
D\eq@freewidth  % eq@linewidth - space for number
Q\relax
<code)
(.init (cseq@indentstep<cs) to a nonzero value so that we can
detect and refrain from clobbering a user setting of zero<.)
(.and (cseq@sidespace<cs) to (csmaxdimen<cs) because
that is the right init before computing a min<.)
(code
\eq@indentstep=\maxdimen
\eq@sidespace=\maxdimen
\let\given@sidespace\@empty
<code)

(define(macroeq@overrun<macro)
(para
(.not a dimen register; don't need to advance it<.)
(code
\def\eq@overrun{0pt}
<code)
<para)
<define)

(.to initialize (cseqnumside<cs) and (cseqindent<cs) properly,
we may need to grub around a bit in (cs@filelist<cs)<.) (.however,
if the (pkgamsmath<pkg) package was used, we can use its option
data<.) (.more trouble: if a documentclass sends an option of
(optleqno<opt) to (pkgamsmath<pkg) by default, and it gets
overridden by the user with a (optreqno<opt) documentclass option,
then (pkgamsmath<pkg) believes itself to have received
(emphboth<emph) options<.)
(code
\@ifpackagewith{amsmath}{leqno}{%
  \@ifpackagewith{amsmath}{reqno}{}{\def\eqnumside{L}}%
}{%
<code)
(.if the (pkgamsmath<pkg) package was not used, the next
method for testing the (optleqno<opt) option is to see if
(fnleqno.clo<fn) is present in (cs@filelist<cs)<.)
(code
  \def\@tempa#1,leqno.clo,#2#3\@nil{%
    \ifx @#2\relax\else \def\eqnumside{L}\fi
  }%
  \@xp\@tempa\@filelist,leqno.clo,@\@nil
<code)
(.even that test may fail in the case of (clsamsart<cls) if it does
not load (pkgamsmath<pkg)<.) (.then we have to look whether
(csiftagsleft@<cs) is defined, and if so whether it is true<.)
(.this is tricky if you want to be careful about conditional nesting
and don't want to put anything in the hash table unnecessarily<.)
(code
  \if L\eqnumside
  \else
    \@ifundefined{iftagsleft@}{}{%
      \edef\eqnumside{%
        \if TT\csname fi\endcsname\csname iftagsleft@\endcsname
          L\else R\fi
      }%
    }
  \fi
}
<code)
(.a similar sequence of tests handles the (qfleqn or not fleqn<q)
question for the (clsarticle<cls) and (clsamsart<cls)
documentclasses<.)
(code
\@ifpackagewith{amsmath}{fleqn}{%
  \def\eqindent{I}%
}{%
  \def\@tempa#1,fleqn.clo,#2#3\@nil{%
    \ifx @#2\relax\else \def\eqindent{I}\fi
  }%
  \@xp\@tempa\@filelist,fleqn.clo,@\@nil
  \if I\eqindent
  \else
    \@ifundefined{if@fleqn}{}{%
      \edef\eqindent{%
        \if TT\csname fi\endcsname\csname if@fleqn\endcsname
          I\else C\fi
      }%
    }%
  \fi
}
\if I\eqindent
  \@ifundefined{mathindent}{%
    \newdimen\mathindent
  }{%
    \@ifundefined{@mathmargin}{}{%
      \mathindent\@mathmargin
    }%
  }
\fi
<code)
<para)
<section)

(section(titlemeasuring equation components<title)
(para(.measure the left-hand side of an equation<.) (.this
function is called by mathrel symbols<.) (.for the first mathrel we
want to discourage a line break more than for following mathrels; so
(csmark@lhs<cs) gobbles the following (csrel@break<cs) and
substitutes a higher penalty<.)
(aside(.maybe the LHS should be kept in a separate box<.)<aside)
<para)

(define(macroEQ@hasLHS<macro)
(para
(?boolean: does this equation have a (qqleft-hand side<qq)<?)
(code
\let\EQ@hasLHS=\@False
<code)
<para)
<define)

(define(macroEQ@QED<macro)
(para
(.if nonempty: the qed material that should be incorporated into this
equation after the final punctuation<.)
(code
\let\EQ@QED=\@empty
<code)
<para)
<define)

(define(macromark@lhs<macro)
(para
(code
\def\mark@lhs#1{%
  \ifnum\lr@level<\@ne
    \let\mark@lhs\relax
    \global\let\EQ@hasLHS=\@True
    \global\let\EQ@prebin@space\EQ@prebin@space@a
    \mark@lhs@a
<code)
(.but the penalty for the first mathrel should still be lower than a
binoppenalty<.) (.if not, when the LHS contains a binop, the split
will occur inside the LHS rather than at the mathrel<.)
(.on the other hand if we end up with a multline sort of equation
layout where the RHS is very short, the break before the relation symbol
should be made (emphless<emph) desirable than the breakpoints inside
the LHS<.)
(.since a lower penalty takes precedence over a higher one, we start
by putting in the highest relpenalty; during subsequent measuring if we
find that that RHS is not excessively short then we put in an extra
(qqnormal<qq) relpenalty when rejoining the LHS and RHS<.)
(code
    \penalty9999 % instead of normal \rel@break
  % else no penalty = forbid break
  \fi
}
<code)
<para)
<define)

(define(macromark@lhs@a<macro)
(para
(.temporarily add an extra thickmuskip to the LHS; it will be removed
later<.) (.this is necessary to compensate for the disappearance of
the thickmuskip glue preceding a mathrel if a line break is taken at
that point<.) (.otherwise we would have to make our definition of
mathrel symbols more complicated, like the one for mathbins<.) (.the
penalty of (m2<m) put in with vadjust is a flag for
(cseq@repack<cs) to suggest that the box containing this line should
be measured to find the value of (cseq@wdL<cs)<.) (.the
second vadjust ensures that the normal prerelpenalty and thickmuskip
will not get lost at the line break during this preliminary pass<.)
(code
\def\mark@lhs@a{%
  \mskip\thickmuskip \@@vadjust{\penalty\tw@}\penalty-\@Mi\@@vadjust{}%
}
<code)
<para)
<define)

(define(macrohiderel<macro)
(para(.if you want the LHS to extend past the first mathrel symbol to a
following one, mark the first one with (cshiderel<cs):
(literal
a \hiderel{=} b = c...
<literal)
<.)
(aside(.I'm not sure now why I didn't use (csbegingroup<cs)
(csendgroup<cs) here (dnmjd,1999/01/21<dn)<.)<aside)
(code
\newcommand\hiderel[1]{\mathrel{\advance\lr@level\@ne#1}}
<code)
<para)<define)

(define(macrom@@Bin<macro)
(macrom@@Rel<macro)
(macrobin@break<macro)
(macrorel@break<macro)
(macrobin@mark<macro)
(macrorel@mark<macro)
(macrod@@Bin<macro)
(macrod@@Rel<macro)
(para
(.[cf] (pkgflexisym<pkg) handling of mathbins and mathrels<.) (.these
are alternate definitions of (csm@Bin<cs) and (csm@Rel<cs),
activated by (csdisplay@setup<cs)<.)
(code
\let\m@@Bin\m@Bin
\let\m@@Rel\m@Rel
\let\EQ@prebin@space\relax
\def\EQ@prebin@space@a{\mskip-\eq@binoffset \keep@glue \mskip\eq@binoffset}
\def\bin@break{\ifnum\lastpenalty=\z@\penalty\prebinoppenalty\fi
  \EQ@prebin@space}
\def\rel@break{%
  \ifnum\abs@num\lastpenalty <\abs@num\prerelpenalty
    \penalty\prerelpenalty
  \fi
}
\def\d@@Bin{\bin@break \m@@Bin}
\def\d@@Rel{\mark@lhs \rel@break \m@@Rel}
<code)
(.the difficulty of dealing properly with the subscripts and
superscripts sometimes appended to mathbins and mathrels is one of the
reasons that we do not attempt to handle the mathrels as a separate
(qcolumn<q) a la (enveqnarray<env)<.)
<para)
<define)

(define(macrom@@symRel<macro)
(macrod@@symRel<macro)
(macrom@@symBin<macro)
(macrod@@symBin<macro)
(macrom@@symDel<macro)
(macrod@@symDel<macro)
(macrom@@symDeR<macro)
(macrod@@symDeR<macro)
(macrom@@symDeB<macro)
(macrod@@symDeB<macro)
(macrom@@symDeA<macro)
(macrod@@symDeA<macro)
(para
(.more of the same<.)
(code
\let\m@@symRel\@symRel \def\d@@symRel{\mark@lhs \rel@break \m@@symRel}
\let\m@@symBin\@symBin \def\d@@symBin{\bin@break \m@@symBin}
\let\m@@symDel\@symDel
\let\m@@symDeR\@symDeR
\let\m@@symDeB\@symDeB
\let\m@@symDeA\@symDeA
<code)
<para)
<define)

(define(macrodisplay@setup<macro)
(seteverydisplay<set)
(para(.setup<.) (.note that [latex] reserves the primitive
(cseverydisplay<cs) under the name (csfrozen@everydisplay<cs)<.)
(code
\global\everydisplay\expandafter{\the\everydisplay \display@setup}
<code)
(.change some math symbol function calls<.)
(code
\def\display@setup{%
  \medmuskip\Dmedmuskip \thickmuskip\Dthickmuskip
  \let\m@Bin\d@@Bin \let\m@Rel\d@@Rel
  \let\@symRel\d@@symRel \let\@symBin\d@@symBin
  \let\m@DeL\d@@DeL \let\m@DeR\d@@DeR \let\m@DeB\d@@DeB
  \let\m@DeA\d@@DeA
  \let\@symDeL\d@@symDeL \let\@symDeR\d@@symDeR
  \let\@symDeB\d@@symDeB \let\@symDeA\d@@symDeA
  \let\left\eq@left \let\right\eq@right \global\lr@level\z@
<code)
(!if we have an embedded array environment (pfor example<p), we
don't want to have each math cell within the array resetting
(cslr@level<cs) globally to 0[mdash]not good<!)
(.and in general I think it is safe to say that whenever we have a
subordinate level of boxing we want to revert to a normal math setup<.)
(code
  \everyhbox{\everyhbox\@emptytoks
    \let\display@setup\relax \textmath@setup \let\textmath@setup\relax
  }%
  \everyvbox{\everyvbox\@emptytoks
    \let\display@setup\relax \textmath@setup \let\textmath@setup\relax
  }%
}
<code)
(.the (cstextmath@setup<cs) function is needed for embedded inline
math inside text inside a display<.)
(code
\def\textmath@setup{%
  \let\m@Bin\m@@Bin \let\m@Rel\m@@Rel
  \let\@symRel\m@@symRel \let\@symBin\m@@symBin
  \let\m@DeL\m@@DeL \let\m@DeR\m@@DeR \let\m@DeB\m@@DeB
  \let\m@DeA\m@@DeA
  \let\@symDeL\m@@symDeL \let\@symDeR\m@@symDeR
  \let\@symDeB\m@@symDeB \let\@symDeA\m@@symDeA
  \let\left\@@left \let\right\@@right
}
<code)
<para)
<define)
(define(macroif@display<macro)
(seteverydisplay<set)
(para(.the test (csifinner<cs) is unreliable for distinguishing
whether we are in a displayed formula or an inline formula: any display
more complex than a simple one-line equation typically involves the use
of (qc$<qc) (csdisplaystyle<cs) [dots] (qc$<qc) instead of
[dbldollars] [dots] [dbldollars]<.) (.so we provide a more reliable
test<.) (.but it might have been provided already by the
(pkgamsmath<pkg) package<.)
(code
\@ifundefined{@displaytrue}{%
  \@xp\newif\csname if@display\endcsname
  \everydisplay\@xp{\the\everydisplay \@displaytrue}
}{}
<code)
<para)
(para(aside(?is there any reason to maintain separate
(cseverydisplay<cs) and (cneqstyle<cn)<?)
<aside)
<para)
<define)
<section)

(section(titleThe (envdmath<env) and (envdmath*<env)
environments<title)
(para(.options for the (envdmath<env) and (envdmath*<env)
environments<.)
(code
% \begin{dmath}[label={xyz}]
\define@key{breqn}{label}{\def\next@label{\label{#1}}}
\global\let\next@label\@empty
<code)
(.allow a variant number<.)
(code
% \begin{dmath}[number={\nref{foo}\textprime}]
\define@key{breqn}{number}{\def\eq@number{#1}%
  \let\@currentlabel\eq@number
}
<code)
(.holding or shifting the number<.)
(code
% \begin{dmath}[shiftnumber]
\define@key{breqn}{shiftnumber}{\let\eq@shiftnumber\@True}
% \begin{dmath}[holdnumber]
\define@key{breqn}{holdnumber}{\let\eq@holdnumber\@True}
<code)
(code
% \begin{dmath}[density={.5}]
\define@key{breqn}{density}{\def\eq@density@factor{#1}}
<code)
(.to change the amount of indent for post-initial lines<.) (.note:
for lines that begin with a mathbin symbol there is a fixed amount of
indent already built in (p(cseqbinoffset<cs)<p) and it cannot be
reduced through this option<.) (.the indentstep amount is the indent
used for lines that begin with a mathrel symbol<.)
(code
% \begin{dmath}[indentstep={1em}]
\define@key{breqn}{indentstep}{\eqindentstep#1\relax}
<code)
(.to make mathrels stay inline to the extent possible, use the compact
option<.)
(.can give a numeric value in the range (m-10000 [dots] 10000<m)
to adjust the behavior<.)
(.(m-10000<m): always break at a rel symbol; (m10000<m): never
break at a rel symbol<.)
(code
% \begin{dmath}[compact]
\define@key{breqn}{compact}[-99]{\prerelpenalty=#1\relax}
<code)
(.specify a particular layout<.)
(.we take care to ensure that (cseq@layout<cs) ends up containing
one and only one letter<.)
(code
% \begin{dmath}[layout={S}]%
\define@key{breqn}{layout}[?]{%
  \edef\eq@layout{\@car#1?\@nil}%
}
<code)
(.to change the interline spacing in a particular equation<.)
(code
% \begin{dmath}[spread={1pt}]
\define@key{breqn}{spread}{%
  \advance\eqlinespacing#1%
  \advance\eqlineskip#1\eqlineskiplimit\eqlineskip
}
<code)
(.to change the amount of space on the side for (qqmultline<qq) layout<.)
(code
\define@key{breqn}{sidespace}{%
  \dimen@#1\relax % error checking
  \def\given@sidespace{#1}%
}
<code)
(.the (optstyle<opt) option is mainly intended for changing the
type size of an equation but as a matter of fact you could put arbitrary
[latex] code here [mdash] thus the option name is (qstyle<q) rather
than just (qtypesize<q)<.) (.in order for this option to work when
setting options globally, we need to put the code in
(cseqstyle<cs) rather than execute it directly<.)
(code
% \begin{dmath}[style={\small}]
\define@key{breqn}{style}{\eqstyle\@xp{\the\eqstyle #1}}
<code)
(.the (optframe<opt) option merely puts a framebox around the body
of the equation<.) (.to change the thickness of the frame, give the
thickness as the argument of the option<.) (.for greater control, you
can change the appearance of the frame by redefining
(cseqframe<cs)<.) (.it must be a command taking two arguments, the
width and height of the equation body<.) (.the top left corner of the
box produced by (cseqframe<cs) will be pinned to the top-left corner
of the equation body<.)
(code
% \begin{dmath}[frame]
\define@key{breqn}{frame}[\fboxrule]{\let\eq@frame=T%
  \dim@a#1\relax\edef\eq@framewd{\the\dim@a}%
<code)
(.until such time as we provide a frame implementation that allows the
frame to stretch and shrink, we'd better remove any stretch/shrink from
the interline glue in this case<.)
(code
  \freeze@glue\eqlinespacing \freeze@glue\eqlineskip
}
\define@key{breqn}{fullframe}[]{\let\eq@frame=U%
  \freeze@glue\eqlinespacing \freeze@glue\eqlineskip
}
\let\eq@frame=F % no frame
\def\eq@framewd{\fboxrule}
<code)
(?wishful thinking<?)
(literal
\begin{dmath}[frame={width={2pt},color={blue},sep={2pt}}]
<literal)
(.to change the space between the frame and the equation there is a
framesep option<.)
(code
\define@key{breqn}{framesep}[\fboxsep]{%
  \ifx\eq@frame=F\let\eq@frame=T\fi
  \dim@a#1\relax \edef\eq@framesep{\the\dim@a}%
  \freeze@glue\eqlinespacing \freeze@glue\eqlineskip
}
\def\eq@framesep{\fboxsep}
<code)
(.foreground and background colors for the equation<.) (.by default
the background area that is colored is the size of the equation, plus
fboxsep<.) (.if you need anything fancier for the background, you'd
better do it by defining (cseqframe<cs) in terms of
(cscolorbox<cs) or (csfcolorbox<cs)<.)
(code
% \begin{dmath}[background={red}]
\define@key{breqn}{background}{\def\eq@background{#1}%
  \freeze@glue\eqlinespacing \freeze@glue\eqlineskip
}
%
% \begin{dmath}[color={purple}]
\define@key{breqn}{color}{\def\eq@foreground{#1}}
<code)
(.the (optcenter<opt) option means add leftskip stretch to make the
individual lines be centered; this is the default for
(envdseries<env)<.)
(code
% \begin{dmath}[center]
\define@key{breqn}{center}[]{\let\eq@centerlines\@True}
\let\eq@centerlines\@False
<code)
(.equation groups normally have alignment of the primary relation
symbols across the whole group<.) (.the (optnoalign<opt) option
switches that behavior<.)
(code
% \begin{dgroup}[noalign]
\define@key{breqn}{noalign}[]{\let\grp@align\@False}
\let\grp@align\@True % default
<code)
(.break depth of 2 means that breaks are allowed at mathbin symbols
inside two pairs of  delimiters, but not three<.)
(code
% \begin{dgroup}[breakdepth={2}]
\define@key{breqn}{breakdepth}{\eqbreakdepth#1\relax}
<code)
(.the (optcols<opt) option only makes sense for the
(envdarray<env) environment but we liberally allow all the options to
be used with all the environments and just ignore any unsensible ones
that happen to come along<.)
(code
% \begin{darray}[cols={lcrlcr}]
\define@key{breqn}{cols}{\global\let\@preamble\@empty
  \darray@mkpream#1\@percentchar
}
<code)
<para)

(define(macrodmath<macro)
(macroenddmath<macro)
(para(.for the (envdmath<env) environment we don't want the standard
optional arg processing because of the way it skips over whitespace,
including newline, while looking for the (qc[<qc) char; which is not good
for math material<.) (.so we call (cs@optarg<cs) instead<.)
(code
\newenvironment{dmath}{\@eq@numbertrue \@optarg\@dmath{}}{}
\def\@dmath[#1]{%
  \if\eq@group\else\eq@prelim\fi
  \setkeys{breqn}{#1}%
  \the\eqstyle
<code)
(.the equation number might have been overridden in [arg1]<.)
(code
  \eq@setnumber
<code)
(.start up the displayed equation by reading the contents into a
box register<.) (.enclose this phase in an extra group so that
modified (cshsize<cs) and other params will be auto-restored
afterwards<.)
(code
  \begingroup
  \eq@setup@a
  \eq@startup
}
<code)
(.before it finishes off the box holding the equation body,
(csenddmath<cs) needs to look ahead for punctuation (pand
(csqed<cs)?<p)<.)
(code
\def\enddmath#1{\check@punct@or@qed}
\def\end@dmath{%
  \eq@capture
  \endgroup
  \EQ@setwdL
<code)
(.measure (pa copy of<p) the equation body to find the minimum width
required to get acceptable line breaks, how many lines will be required
at that width, and whether the equation number needs to be shifted to
avoid overlapping<.) (.this information will then be used by
(cseq@finish<cs) to do the typesetting of the real equation body<.)
(code
  \eq@measure
<code)
(.piece together the equation from its constituents, recognizing
current constraints<.) (.if we are in an equation group, this might
just save the material on a stack for later processing<.)
(code
  \if\eq@group \grp@push \else \eq@finish\fi
}
<code)
<para)<define)
(define(macrodmath*<macro)
(macroenddmath*<macro)
(para(.ah yes, now the lovely (envdmath*<env) environment<.)
(code
\newenvironment{dmath*}{%
  \@eq@numberfalse \@optarg\@dmath{}%
}{}
\@namedef{end@dmath*}{\end@dmath}
\@namedef{enddmath*}#1{\check@punct@or@qed}
<code)
<para)<define)

(define(macroeq@prelim<macro)
(para(.if (cseverypar<cs) has a non-null value, it's probably
some code from (cs@afterheading<cs) that sets (csclubpenalty<cs)
and[slash]or removes the parindent box<.) (.both of those actions
are irrelevant and interfering for our purposes and need to be deflected
for the time being<.)
(.if an equation appears at the very beginning of a list item
(ppossibly from a trivlist such as (envproof<env)<p), we need to
trigger the item label<.)
(code
\def\eq@prelim{%
  \if@inlabel \indent \par \fi
  \if@nobreak \global\@nobreakfalse \predisplaypenalty\@M \fi
  \everypar\@emptytoks
<code)
(.if for some reason (envdmath<env) is called between paragraphs,
(cnnoindent<cn) is better than (cnleavevmode<cn), which would produce
an indent box and an empty line to hold it<.) (.if we are in a list
environment, (cnpar<cn) is defined as ("{\@@par}<") to preserve
(csparshape<cs)<.)
(code
  \noindent
  \eq@nulldisplay
  \par %% \eq@saveparinfo %% needs work
  \let\intertext\breqn@intertext
}
<code)
(.warning message extracted to a separate function to streamline the
calling function<.)
(code
\def\breqn@parshape@warning{%
  \PackageWarning{breqn}{%
    Complex paragraph shape cannot be followed by this equation}%
}
<code)
<para)
<define)

(define(macroeq@prevshape<macro)
(para
(.storage; see (cseq@saveparinfo<cs)<.)
(code
\let\eq@prevshape\@empty
<code)
<para)
<define)

(define(macroeq@saveparinfo<macro)
(para
(.save the number of lines and parshape info for the text preceding
the equation<.)
(code
\def\eq@saveparinfo{%
  \count@\prevgraf \advance\count@-\thr@@ % for the null display
  \edef\eq@prevshape{\prevgraf\the\count@\space}%
  \ifcase\parshape
    % case 0: no action required
  \or \edef\eq@prevshape{\eq@prevshape
        \parshape\@ne\displayindent\displaywidth\relax
      }%
<code)
(.maybe best to set (cseq@prevshape<cs) the same in the else case
also<.) (.better than nothing<.)
(code
  \else
    \breqn@parshape@warning
  \fi
}
<code)
<para)
<define)

(define(macroeq@setnumber<macro)
(para(.if the current equation number is not explicitly given, then
use an auto-generated number, unless the no-number switch has been
thrown (p(envdmath*<env)<p)<.)
(.(cstheequation<cs) is the number form to be used for all equations,
(cseq@number<cs) is the actual value for the current equation
(pmight be an exception to the usual sequence<p)<.)
(code
\def\eq@setnumber{%
  \if@eq@number
    \ifx\eq@number\@empty
      \stepcounter{equation}\let\eq@number\theequation
    \fi
  \fi
  \ifx\eq@number\@empty
  \else
<code)
(.put the number in a box so we can use its measurements in our
number-placement calculations<.) (.the extra braces around
(cseqnumform<cs) make it possible for (cseqnumfont<cs) to have
either an (csitshape<cs) (precommended<p) or a (cstextit<cs)
value<.)
(code
    \set@label{equation}\eq@number
    \global\sbox\EQ@numbox{%
      \next@label \global\let\next@label\@empty
      \eqnumcolor\eqnumsize
      \eqnumfont{\eqnumform{\eq@number}}%
    }%
    \@eq@numbertrue % locally true
  \fi
}
<code)
<para)
<define)

(define(macroeq@finish<macro)
(para(.the information available at this point from preliminary
measuring includes the number of lines required, the width of the
equation number, the total height of the equation body, and (pmost
important<p) the parshape spec that was used in determining height and
number of lines<.)
(code
\def\eq@finish{%
  \begingroup
  \csname eq@\eqindent \if@eq@number\eqnumside\eqnumplace\fi\endcsname
  \endgroup
  \eq@botspace
}
<code)
<para)
<define)
<section)

(section(titlespecial processing for end-of-equation<title)
(para
(.at the end of a displayed equation environment we need to peek ahead
for two things: following punction such as period or command that
should be pulled in for inclusion at the end of the equation; and
possibly also an ("\end{proof}<") with an implied (qqqed<qq)
symbol that is traditionally included at the end of the display rather
than typeset on a separate line<.)
(.we could require that the users type (csqed<cs) explicitly at the
end of the display when they want to have the display take notice of it<.)
(.but the reason for doing that would only be to save work for the
programmer; the most natural document markup would allow an inline
equation and a displayed equation at the end of a proof to differ only
in the environment name:
(literal
... \begin{math} ... \end{math}.
\end{proof}
<literal)
versus
(literal
...
\begin{dmath}
 ...
\end{dmath}.
\end{proof}
<literal)
<.)
(.the technical difficulties involved in supporting this markup within
[latex2e] are, admittedly, nontrivial<.)
(.nonetheless, let's see how far we can go<.)
<para)
(para
(.the variations that we will support are only the most
straightforward ones:
(literal
\end{dmath}.
\end{proof}
<literal)
or
(literal
\end{dmath}.
% Perhaps a comment
\end{proof}
<literal)
<.)
(.if there is anything more complicated than a space after the
period we will not attempt to scan any further for a possible
("\end{proof}<")<.)
(.this includes material such as:
(literal
\begin{figure}...\end{figure}%
\footnote{...}
\renewcommand{\foo}{...}
\par
<literal)
or even a blank line[mdash]because in [latex] a blank line is
equivalent to (cspar<cs) and the meaning of (cspar<cs) is
(qqend-paragraph<qq); in my opinion if explicit end-of-paragraph
markup is given before the end of an element, it has to be respected,
and the preceding paragraph has to be fully finished off before
proceeding further, even inside an element like (qqproof<qq) whose
end-element formatting requires integration with the end of the
paragraph text<.)
(.And [tex]nically speaking, a (cspar<cs) token that comes from a
blank line and one that comes from the sequence of characters
(qc\<qc) (qcp<qc) (qca<qc) (qcr<qc) are equally explicit<.)
(.I hope to add support for (csfootnote<cs) in the future, as it
seems to be a legitimate markup possibility in that context from a
purely logical point of view, but there are additional technical
complications if one wants to handle it in full generality
(dnmjd,1999/02/08<dn)<.)
<para)

(define(macropeek@branch<macro)
(para
(.this is a generalized (qqlook at next token and choose some action
based on it<qq) function<.)
(code
\def\peek@branch#1#2{%
  \let\peek@b#1\let\peek@space#2\futurelet\@let@token\peek@a
}
\def\peek@skipping@spaces#1{\peek@branch#1\peek@skip@space}
\def\peek@a{%
  \ifx\@let@token\@sptoken \expandafter\peek@space
  \else \expandafter\peek@b\fi
}
\lowercase{\def\peek@skip@space} {\futurelet\@let@token\peek@a}%
<code)
<para)
<define)

(define(macrocheck@punct<macro)
(para
(.for this one we need to recognize and grab for inclusion any of the
following tokens: (",;.!?<"), both catcode 12 (pstandard [latex]
value<p) and catcode 13 (pas might hold when the Babel package is
being used<p)<.)
(.we do not support a space preceding the punctuation since that would
be considered simply invalid markup if a display-math environment were
demoted to in-line math; and we want to keep their markup as parallel as
possible<.)
(.if punctuation does not follow, then the (cscheck@qed<cs) branch
is not applicable<.)
(code
\def\check@punct{\futurelet\@let@token\check@punct@a}
\def\check@punct@a{%
  \edef\@tempa{%
    \ifx\@let@token\@sptoken\@nx\finish@end
    \else\ifx\@let@token ,\@nx\check@qed
    \else\ifx\@let@token .\@nx\check@qed
    \else\check@punct@b % check the less common possibilities
    \fi\fi\fi
  }%
  \@tempa
}
\begingroup
\toks@a{%
  \ifx\@let@token ;\@nx\check@qed
  \else\ifx\@let@token ?\@nx\check@qed
  \else\ifx\@let@token !\@nx\check@qed
}
\toks@c{\fi\fi\fi}% matching with \toks@a
\catcode`\.=\active \catcode`\,=\active \catcode`\;=\active
\catcode`\?=\active \catcode`\!=\active
\toks@b{
  \else\ifx\@let@token ,\@nx\check@qed
  \else\ifx\@let@token .\@nx\check@qed
  \else\ifx\@let@token ;\@nx\check@qed
  \else\ifx\@let@token ?\@nx\check@qed
  \else\ifx\@let@token !\@nx\check@qed
  \fi\fi\fi\fi\fi
}
\xdef\check@punct@b{%
  \the\toks@a\the\toks@b\the\toks@c
}
\endgroup
<code)

(code
\let\found@punct\@empty
\def\check@qed#1{%
  \gdef\found@punct{#1}%
  \peek@skipping@spaces\check@qed@a
}
\def\check@qed@a{%
  \ifx\end\@let@token \@xp\check@qed@b
  \else \@xp\finish@end
  \fi
}
<code)
(.for each environment ENV that takes an implied qed at the end, the
control sequence ENVqed must be defined; and it must include suitable
code to yield the desired results in a displayed equation<.)
(code
\def\check@qed@b#1#2{%
  \@ifundefined{#2qed}{}{%
    \toks@\@xp{\found@punct\csname#2qed\endcsname}%
    \xdef\found@punct{\the\toks@}%
  }%
  \finish@end
  \end{#2}%
}
<code)
<para)
<define)

(define(macrolatex@end<macro)
(macrofinish@end<macro)
(para(.The lookahead for punctuation following a display requires
mucking about with the normal operation of (cnend<cn)<.) (?although
this is not exactly something to be done lightly, on the other hand this
whole package is so over-the-top anyway, what's a little more
going to hurt<?) (.and rationalizing this aspect of
equation markup is a worthy cause<.) (.here is the usual
definition of (csend<cs)<.)
(literal
\def\end#1{
  \csname end#1\endcsname \@checkend{#1}%
  \expandafter\endgroup\if@endpe\@doendpe\fi
  \if@ignore \global\@ignorefalse \ignorespaces \fi
}
<literal)
(.we can improve the chances of this code surviving through future
minor changes in the fundamental definition of (csend<cs) by taking a
little care in saving the original meaning<.)
(code
\def\@tempa#1\endcsname#2\@nil{\def\latex@end##1{#2}}
\expandafter\@tempa\end{#1}\@nil
\def\end#1{\csname end#1\endcsname \latex@end{#1}}%
<code)
(?why don't we call (csCheckCommand<cs) here<?) (.because that
doesn't help end users much; it works better to use it during package
testing by the maintainer<.)
<para)
(para
(.if a particular environment needs to call a different end action, the
end command of the environment should be defined to gobble two args and
then call a function like (cscheck@punct@or@qed<cs)<.)
(code
\def\check@punct@or@qed#1{%
  \def\finish@end{\csname end@#1\endcsname\latex@end{#1}}%
  \check@punct
}
<code)
<para)
<define)

(define(macroeqpunct<macro)
(para(.user-settable function for handling
the punctuation at the end of an equation<.) (.you could, for example,
define it to just discard the punctuation<.)
(code
\newcommand\eqpunct[1]{\thinspace#1}
<code)
<para)
<define)

(define(macroset@label<macro)
(para(.(csset@label<cs) just sets (cs@currentlabel<cs) but it
takes the counter as an argument, in the hope that [latex] will some
day provide an improved labeling system that includes type info on the
labels<.)
(code
\providecommand\set@label[2]{\protected@edef\@currentlabel{#2}}
<code)
<para)
<define)

(define(macroeq@topspace<macro)
(macroeq@botspace<macro)
(para(.the action of (cseq@topspace<cs) is complicated by the
need to test whether the (qshort<q) versions of the display skips
should be used<.) (.this can be done only after the final parshape
and indent have been determined, so the calls of this function are
buried relatively deeply in the code by comparison to the calls of
(cseq@botspace<cs)<.) (.this also allows us to optimize
slightly by setting the above-skip with (csparskip<cs) instead of
(csvskip<cs)<.) (.[arg1] is either (csnoindent<cs) or
("\vskip\parskip<")<.)
(code
\def\eq@topspace#1{%
  \begingroup
    \global\let\EQ@shortskips\@False
    \if\@And{\eq@group}{\@Not\GRP@top}%
      \parskip\intereqskip \penalty\intereqpenalty
    \else
      \advance\leftskip-2em % standard TeX value
      \ifdim\leftskip>\predisplaysize
        \global\let\EQ@shortskips\@True
        \parskip\abovedisplayshortskip
        \aftergroup\belowdisplayskip\aftergroup\belowdisplayshortskip
      \else
        \parskip\abovedisplayskip
      \fi
    \fi
    \ifx F\eq@frame
    \else
      \advance\parskip\eq@framesep \advance\parskip\eq@framewd\relax
    \fi
    #1%
  \endgroup
}
<code)
<para)
(para(.at the end of an equation, need to put in a pagebreak penalty
and some vertical space<.) (.also set some flags to remove parindent
and extra word space if the current paragraph text continues without an
intervening (cspar<cs)<.)
(code
\def\eq@botspace{%
  \penalty\postdisplaypenalty
<code)
(.earlier calculations will have set (csbelowdisplayskip<cs) locally
to (csbelowdisplayshortskip<cs) if applicable<.) (.so we can just use
it here<.)
(code
  \ifx F\eq@frame
  \else
    \advance\belowdisplayskip\eq@framesep
    \advance\belowdisplayskip\eq@framewd\relax
  \fi
  \vskip\belowdisplayskip
  \@endpetrue % kill parindent if current paragraph continues
  \global\@ignoretrue % ignore following spaces
  \eq@resume@parshape
}
<code)
<para)<define)

(define(macroeq@resume@parshape<macro)
(para(.this should calculate the total height of the equation,
including space above and below, and set prevgraf to the number it would
be if that height were taken up by normally-spaced normal-height
lines<.) (.we also need to restore parshape if it had a non-null
value before the equation<.) (.not implemented yet<.)
(code
\def\eq@resume@parshape{}
<code)
<para)<define)

<section)
(section(titlepreprocessing the equation body<title)
(define(macroeq@startup<macro)
(para(.here is the function that initially collects the equation
material in a box<.)
<para)
(para
(code
\def\eq@startup{%
  \global\let\EQ@hasLHS\@False
  \setbox\z@\vbox\bgroup
    \noindent \@@math \displaystyle
    \penalty-\@Mi
}
<code)
<para)
(para(.this setup defines the environment for the first typesetting
pass, note the (cshsize<cs) value for example<.)
(code
\def\eq@setup@a{%
  \everymath\everydisplay
  %\let\@newline\eq@newline % future possibility?
  \let\\\eq@newline
  \let\insert\eq@insert \let\mark\eq@mark \let\vadjust\eq@vadjust
  \hsize\maxdimen \pretolerance\@M
<code)
(.here it is better not to use (cs@flushglue<cs) (p0pt
plus1fil<p) for (csrightskip<cs), or else a negative penalty
(psuch as (m-99<m) for (csprerelpenalty<cs)<p) will tempt
[tex] to use more line breaks than necessary in the first typesetting
pass<.) (.ideal values for (csrightskip<cs) and
(cslinepenalty<cs) are unclear to me, but they are rather sensitively
interdependent<.) (.choice of 10000 pt for rightskip is derived by
saying, let's use a value smaller than 1 fil and smaller than
(cshsize<cs), but more than half of (cshsize<cs) so that if a line
is nearly empty, the glue stretch factor will always be less than 2.0
and so the badness will be less than 100 and so [tex] will not issue
badness warnings<.)
(code
  \linepenalty\@m
  \rightskip\z@\@plus\@M\p@ \leftskip\z@skip \parfillskip\z@skip
  \clubpenalty\@ne \widowpenalty\z@ \interlinepenalty\z@
<code)
(.after a relation symbol is discovered, binop symbols should start
including a special offset space<.)
(.but until then (csEQ@prebin@space<cs) is a no-op<.)
(code
  \global\let\EQ@prebin@space\relax
<code)
(.set binoppenalty and relpenalty high to prohibit line breaks
after mathbins and mathrels<.) (.as a matter of fact, the penalties are
then omitted by [tex], since bare glue without a penalty is
(emphnot<emph) a valid breakpoint if it occurs within
mathon[ndash]mathoff items<.)
(code
  \binoppenalty\@M \relpenalty\@M
}
<code)
<para)<define)
(floatseries=figure
(figure(titlepreliminary equation contents, part 1<title)
(para(.the contents of an equation after the initial typesetting pass,
as shown by (csshowlists<cs)<.) (.this is the material on which the
(cseq@repack<cs) function operates<.) (.the equation was
(literal
a=b +\left(\frac{c\sp 2}{2} -d\right) +(e -f) +g
<literal)
<.) (.the contents are shown in four parts in this figure and the next
three<.) (.the first part contains two line boxes, one for the mathon
node and one for the LHS<.)
(literal
\hbox(0.0+0.0)x16383.99998, glue set 1.6384
.\mathon
.\penalty -10000
.\glue(\rightskip) 0.0 plus 10000.0
\penalty 1
\glue(\baselineskip) 7.69446
\hbox(4.30554+0.0)x16383.99998, glue set 1.63759
.\OML/cmm/m/it/10 a
.\glue 2.77771 minus 1.11108
.\penalty -10001
.\glue(\rightskip) 0.0 plus 10000.0
\penalty 2
\glue(\lineskip) 1.0
...
<literal)
<para)
<figure)<float)
(floatseries=figure
(figure(titlepreliminary equation contents, part 2<title)
(para(.this is the first part of the RHS, up to the
(csright<cs), where a line break has been forced so that we can break
open the left-right box<.)
(literal
...
\penalty 2
\glue(\lineskip) 1.0
\hbox(14.9051+9.50012)x16383.99998, glue set 1.63107
.\penalty -99
.\glue(\thickmuskip) 2.77771 minus 1.11108
.\OT1/cmr/m/n/10 =
.\glue(\thickmuskip) 2.77771 minus 1.11108
.\OML/cmm/m/it/10 b
.\penalty 888
.\glue -10.5553
.\rule(*+*)x0.0
.\penalty 10000
.\glue 10.5553
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OT1/cmr/m/n/10 +
.\glue(\medmuskip) 2.22217 minus 1.66663
.\hbox(14.9051+9.50012)x43.36298
..\hbox(0.39998+23.60025)x7.36115, shifted -14.10013
...\OMX/cmex/m/n/5 [hat][hat]R
..\hbox(14.9051+6.85951)x11.21368
...\hbox(14.9051+6.85951)x11.21368
  ... [fraction contents, elided]
..\penalty 5332
..\glue -10.5553
..\rule(*+*)x0.0
..\penalty 10000
..\glue 10.5553
..\glue(\medmuskip) 2.22217 minus 1.66663
..\OMS/cmsy/m/n/10 [hat][hat]@
..\glue(\medmuskip) 2.22217 minus 1.66663
..\OML/cmm/m/it/10 d
..\hbox(0.39998+23.60025)x7.36115, shifted -14.10013
...\OMX/cmex/m/n/5 [hat][hat]S
.\penalty -10000
.\glue(\rightskip) 0.0 plus 10000.0
\penalty 3
\glue(\lineskip) 1.0
...
<literal)
<para)
<figure)<float)
(floatseries=figure
(figure(titlepreliminary equation contents, part 3<title)
(para(.this is the remainder of the RHS after the post-(csright<cs)
split<.)
(literal
...
\penalty 3
\glue(\lineskip) 1.0
\hbox(7.5+2.5)x16383.99998, glue set 1.63239
.\penalty 888
.\glue -10.5553
.\rule(*+*)x0.0
.\penalty 10000
.\glue 10.5553
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OT1/cmr/m/n/10 +
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OT1/cmr/m/n/10 (
.\OML/cmm/m/it/10 e
.\penalty 5332
.\glue -10.5553
.\rule(*+*)x0.0
.\penalty 10000
.\glue 10.5553
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OMS/cmsy/m/n/10 [hat][hat]@
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OML/cmm/m/it/10 f
.\kern1.0764
.\OT1/cmr/m/n/10 )
.\penalty 888
.\glue -10.5553
.\rule(*+*)x0.0
.\penalty 10000
.\glue 10.5553
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OT1/cmr/m/n/10 +
.\glue(\medmuskip) 2.22217 minus 1.66663
.\OML/cmm/m/it/10 g
.\kern0.35878
.\penalty -10000
.\glue(\rightskip) 0.0 plus 10000.0
\glue(\baselineskip) 9.5
...
<literal)
<para)
<figure)<float)
(floatseries=figure
(figure(titlepreliminary equation contents, part 4<title)
(para(.this is the mathoff fragment<.)
(literal
...
\glue(\baselineskip) 9.5
\hbox(0.0+0.0)x16383.99998, glue set 1.6384
.\mathoff
.\penalty 10000
.\glue(\parfillskip) 0.0
.\glue(\rightskip) 0.0 plus 10000.0
<literal)
<para)
<figure)<float)

(define(macroeq@capture<macro)
(macroeq@punct<macro)
(para(.if an equation ends with a (csright<cs) delim, the last thing
on the math list will be a force-break penalty<.) (.then don't
redundantly add another forcing penalty<.) (?[lparen]question: when does a
penalty after a linebreak not disappear<?) (.answer: when you have
two forced break penalties in a row[rparen]<.) (.ending punctuation, if
any, goes into the last box with the mathoff kern<.) (.if the math list
ends with a slanted letter, then there will be an italic correction
added after it by [tex]<.) (?should we remove it<?) (.i guess
so<.)
(code
\def\eq@capture{%
  \ifnum\lastpenalty>-\@M \penalty-\@Mi \fi
<code)
(.we want to keep the mathoff kern from vanishing at the line break,
so that we can reuse it later<.)
(code
  \keep@glue\@@endmath
  \eq@addpunct
  \@@par
  \eq@wdL\z@
<code)
(.first snip the last box, which contains the mathoff node, and put it
into (csEQ@box<cs)<.) (.then when we call (cseq@repack<cs) it
will recurse properly<.)
(code
  \setbox\tw@\lastbox
  \global\setbox\EQ@box\hbox{\unhbox\tw@\unskip\unskip\unpenalty}%
  \unskip\unpenalty
  \global\setbox\EQ@copy\copy\EQ@box
%%  \global\setbox\EQ@vimcopy\copy\EQ@vimbox
  \clubpenalty\z@
%\batchmode\showboxbreadth\maxdimen\showboxdepth99\showlists\errorstopmode
  \eq@repack % recursive
<code)
(.finally, add the mathon item to (csEQ@box<cs) and (csEQ@copy<cs)<.)
(code
  \setbox\tw@\lastbox
  \global\setbox\EQ@box\hbox{\unhcopy\tw@\unskip\unpenalty \unhbox\EQ@box}%
  \global\setbox\EQ@copy\hbox{\unhbox\tw@\unskip\unpenalty \unhbox\EQ@copy}%
%\batchmode\showbox\EQ@copy \showthe\eq@wdL\errorstopmode
  \egroup % end vbox started earlier
}
<code)
(.now we have two copies of the equation, one in (csEQ@box<cs),
and one in (csEQ@copy<cs) with inconvenient stuff like inserts and
marks omitted<.)
<para)
(para(.(cseq@addpunct<cs) is for tacking on text punctuation at the end
of a display, if any was captured by the (qgp<q) lookahead<.)
(code
\def\eq@addpunct{%
  \ifx\found@punct\@empty
  \else \eqpunct{\found@punct}%
  \fi
  \EQ@afterspace
}
<code)
(.needed for the (envdseries<env) environment, among other things<.)
(code
\global\let\EQ@afterspace\@empty
<code)
<para)
<define)
(define(macroeq@repack<macro)
(para(.the (cseq@repack<cs) function looks at the information at hand
and proceeds accordingly<.)
(code
\def\eq@repack{%
<code)
(.a previous penalty of 3 on the vertical list means that we need
to break open a left-right box<.)
(code
  \ifcase\lastpenalty
     % case 0: normal case
    \setbox\tw@\lastbox
    \eq@repacka\EQ@copy \eq@repacka\EQ@box
    \unskip
  \or % case 1: finished recursing
<code)
(.grab the mathon object since we need it to inhibit line breaking at
bare glue nodes later<.)
(code
    \unpenalty
    \setbox\tw@\lastbox
    \eq@repacka\EQ@copy \eq@repacka\EQ@box
    \@xp\@gobble
  \or % case 2: save box width = LHS width
<code)
(.don't need to set (csEQ@hasLHS<cs) here because it was set earlier
if applicable<.)
(code
    \unpenalty
    \setbox\tw@\lastbox
    \setbox\z@\copy\tw@ \setbox\z@\hbox{\unhbox\z@\unskip\unpenalty}%
    \advance\eq@wdL\wd\z@
    \xdef\EQ@setwdL{\eq@wdL\the\eq@wdL\relax}%
<code)
(.at this point, box 2 typically ends with
(literal
.\mi10 a
.\glue 2.77771 plus 2.77771
.\penalty -10001
.\glue(\rightskip) 0.0 plus 10000.0
<literal)
and we want to ensure that the thickmuskip glue gets removed<.)
(.and we now arrange for (csEQ@copy<cs) and (csEQ@box<cs) to
keep the LHS in a separate subbox; this is so that we can introduce a
different penalty before the first relation symbol if necessary,
depending on the layout decisions that are made later<.)
(code
    \global\setbox\EQ@copy\hbox{%
      \hbox{\unhcopy\tw@\unskip\unpenalty\unskip}%
      \box\EQ@copy
    }%
    \global\setbox\EQ@box\hbox{%
      \hbox{\unhbox\tw@\unskip\unpenalty\unskip}%
      \box\EQ@box
    }%
    \unskip
  \or % case 3: unpack left-right box
    \unpenalty
    \eq@lrunpack
  \else
    \breqn@repack@err
  \fi
  \eq@repack % RECURSE
}
<code)
(.error message extracted to streamline calling function<.)
(code
\def\breqn@repack@err{%
  \PackageError{breqn}{eq@repack penalty neq 0,1,2,3}\relax
}
<code)
<para)<define)

(define(macroeq@repacka<macro)
(para(.we need to transfer each line into two separate boxes, one
containing everything and one that omits stuff like (csinsert<cs)s
that would interfere with measuring<.)
(code
\def\eq@repacka#1{%
  \global\setbox#1\hbox{\unhcopy\tw@ \unskip
    \count@-\lastpenalty
    \ifnum\count@<\@M \else \advance\count@-\@M \fi
    \unpenalty
<code)
(.if creating the measure copy, ignore all cases above case 3 by
folding them into case 1<.)
(code
    \ifx\EQ@copy#1\ifnum\count@>\thr@@ \count@\@ne\fi\fi
    \ifcase\count@
        % case 0, normal line break
      \penalty-\@M % put back the linebreak penalty
    \or % case 1, do nothing (end of equation)
      \relax
    \or % case 2, no-op (obsolete case)
    \or % case 3, transfer vspace and/or penalty
      \ifx#1\EQ@box \eq@revspace \else \eq@revspaceb \fi
    \or % case 4, put back an insert
      \eq@reinsert
    \or % case 5, put back a mark
      \eq@remark
    \or % case 6, put back a vadjust
      \eq@readjust
    \else % some other break penalty
      \penalty-\count@
    \fi
    \unhbox#1}%
}
<code)
<para)<define)

(define(macroeq@nulldisplay<macro)
(para(.throw in a null display in order to get predisplaysize [etc]<.)
(.my original approach here was to start the null display, then measure
the equation, and set a phantom of the equation's first line before
ending the null display<.) (.that would allow finding out if [tex] used
the short displayskips instead of the normal ones<.) (.but because of
some complications with grouping and the desirability of omitting
unnecessary invisible material on the vertical list, it seems better to
just collect information about the display (pgetting (csprevdepth<cs)
requires (cshalign<cs)<p) and manually perform our own version of
[tex]'s shortskip calculations<.) (.this approach also gives greater
control, [eg], the threshold amount of horizontal space between
predisplaysize and the equation's left edge that determines when the
short skips kick in becomes a designer-settable parameter rather than
hardwired into [tex]<.)
(code
\def\eq@nulldisplay{%
  \begingroup \frozen@everydisplay\@emptytoks
  \@@display
  \predisplaypenalty\@M \postdisplaypenalty\@M
  \abovedisplayskip\z@skip \abovedisplayshortskip\z@skip
  \belowdisplayskip\z@skip \belowdisplayshortskip\z@skip
  \xdef\EQ@displayinfo{%
    \prevgraf\the\prevgraf \predisplaysize\the\predisplaysize
    \displaywidth\the\displaywidth \displayindent\the\displayindent
    \listwidth\the\linewidth
<code)
(.not sure how best to test whether leftmargin should be
added<.) (.let's do this for now [mjd,1997/10/08]<.)
(code
    \ifdim\displayindent>\z@
      \advance\listwidth\the\leftmargin
      \advance\listwidth\the\rightmargin
    \fi
    \relax}%
<code)
(.an (cshalign<cs) containing only one (cscr<cs) (pfor the
preamble<p) puts no box on the vertical list, which means that no
(csbaselineskip<cs) will be added (pso we didn't need to set it to
zero<p) and the previous value of prevdepth carries through<.) (.those
properties do not hold for an empty simple equation without
(cshalign<cs)<.)
(code
  \halign{##\cr}%
  \@@enddisplay
  \par
  \endgroup
  \EQ@displayinfo
}
<code)
<para)<define)

(define(macroeq@newline<macro)
(macroeq@newlinea<macro)
(macroeq@newlineb<macro)
(para(.here we use (cs@ifnext<cs) so that in a sequence like
(literal
...\\
[a,b]
<literal)
[latex] does not attempt to interpret the ("[a,b]<") as a
vertical space amount<.) (.we would have used (cseq@break<cs) in the
definition of (cseq@newlineb<cs) except that it puts in a
(cskeep@glue<cs) object which is not such a good idea if a mathbin
symbol follows [mdash] the indent of the mathbin will be wrong because
the leading negative glue will not disappear as it should at the line
break<.)
(code
\def\eq@newline{%
  \@ifstar{\eq@newlinea\@M}{\eq@newlinea\eqinterlinepenalty}}
\def\eq@newlinea#1{%
  \@ifnext[{\eq@newlineb{#1}}{\eq@newlineb{#1}[\maxdimen]}}
\def\eq@newlineb#1[#2]{\penalty-\@M}
<code)
<para)<define)

(define(macroeq@revspace<macro)
(macroeq@revspaceb<macro)
(para(.when (cseq@revspace<cs) (pre-vspace<p) is called, we are the
end of an equation line; we need to remove the existing penalty of
(m-10002<m) in order to put a vadjust object in front of it, then put
back the penalty so that the line break will still take place in the
final result<.)
(code
\def\eq@revspace{%
  \global\setbox\EQ@vimbox\vbox{\unvbox\EQ@vimbox
    \unpenalty
    \global\setbox\@ne\lastbox}%
  \@@vadjust{\unvbox\@ne}%
  \penalty-\@M
}
<code)
(.the b version is used for the (csEQ@copy<cs) box<.)
(code
\def\eq@revspaceb{%
  \global\setbox\EQ@vimcopy\vbox{\unvbox\EQ@vimcopy
    \unpenalty
    \global\setbox\@ne\lastbox}%
  \@@vadjust{\unvbox\@ne}%
  \penalty-\@M
}
<code)
<para)<define)

(define(macroeq@break<macro)
(para(.the function (cseq@break<cs) does a preliminary linebreak with
a flag penalty<.)
(code
\def\eq@break#1{\penalty-1000#1 \keep@glue}
<code)
<para)<define)
<section)

(section(titlechoosing optimal line breaks<title)
(para(.the question of what line width to use when breaking an
equation into several lines is best examined in the light of an extreme
example<.) (.suppose we have a two-column layout and a displayed
equation falls inside a second-level list with nonzero leftmargin and
rightmargin<.) (.then we want to try in succession a number of
different possibilities<.) (.in each case if the next possibility is
no wider than the previous one, skip ahead to the one after<.)
(enumerate
(item(.first try linewidth(p2<p), the linewidth for the current
level-2 list<.)
<item)
(item(.if we cannot find adequate linebreaks at that width, next try
listwidth(p2<p), the sum of leftmargin, linewidth, and rightmargin for
the current list<.)
<item)
(item(.if we cannot find linebreaks at that width, next try linewidth
(p1<p) (pskipping this step if it is no larger then
listwidth(p2<p)<p)<.)
<item)
(item(.if we cannot find linebreaks at that width, next try
listwidth(p1<p)<.)
<item)
(item(.if we cannot find linebreaks at that width, next try column
width<.)
<item)
(item(.if we cannot find linebreaks at that width, next try text
width<.)
<item)
(item(.if we cannot find linebreaks at that width, next try equation
width, if it exceeds text width (p[ie], if the style allows equations
to extend into the margins<p)<.)
<item)
<enumerate)
<para)

(floatid=f:parshape-1 deferred=true
(figureid=parshape-1
(titlefirst-approximation parshape for equations<title)
(bneeds work<b)<figure)<float)

(para
(.at any given line width, we run through a series of parshape
trials and, essentially, use the first one that gives decent line
breaks<.)
(.but the process is a bit more complicated in fact<.)
(.in order to do a really good job of setting up the parshapes, we
need to know how many lines the equation will require<.)
(!and of course the number of lines needed depends on the parshape<!)
(.so as our very first trial we run a simple first-approximation
parshape (p(refanchor=f:parshape-1parshape-1<ref)<p) whose
main purpose is to get an estimate on the number of lines that will be
needed; it chooses a uniform indent for all lines after the first one
and does not take any account of the equation number<.)
(.a substantial majority of equations only require one line anyway,
and for them this first trial will succeed<.)
(.in the one-line case if there is an equation number and it doesn't
fit on the same line as the equation body, we don't go on to other
trials because breaking up the equation body will not gain us
anything[mdash]we know that we'll have to use two lines in any case
[mdash] so we might as well keep the equation body together on one line
and shift the number to a separate line<.)
<para)
(para(.if we learn from the first trial that the equation body
requires more than one line, the next parshape trial involves adjusting
the previous parshape to leave room for the equation number, if
present<.) (.if no number is present, again no further trials are
needed<.)
<para)
(para(.some remarks about parshape handling<.) (.the [tex]
primitive doesn't store the line specs anywhere, ("\the\parshape<")
only returns the number of line specs<.) (.this makes it well nigh
impossible for different packages that use (csparshape<cs) to work
together<.) (.not that it would be terribly easy for the package
authors to make inter-package collaboration work, if it were
possible<.) (.if we optimistically conjecture that
someone some day may take on such a task, then the thing to do,
obviously, is provide a parshape interface that includes a record of all
the line specs<.) (.for that we designate a macro (cs@parshape<cs)
which includes not only the line specs, but also the line count and even
the leading (csparshape<cs) token<.)
(.this allows it to be directly executed without an auxiliary if-empty
test<.) (.it should include a trailing (csrelax<cs) when it has a
nonempty value<.)
(code
\let\@parshape\@empty
<code)
<para)

(para(.the function (cseq@measure<cs) runs line-breaking trials
on the copy of the equation body that is stored in the box register
(csEQ@copy<cs), trying various possible layouts in order of
preference until we get successful line breaks, where (qsuccessful<q)
means there were no overfull lines<.) (.the result of the trials is,
first, a parshape spec that can be used for typesetting the real
equation body in (csEQ@box<cs), and second, some information that
depends on the line breaks such as the depth of the last line, the
height of the first line, and positioning information for the equation
number<.)(.the two main variables in the equation layout are the line
width and the placement of the equation number, if one is present<.)
<para)

(define(macroeq@measure<macro)
(para(.run linebreak trials on the equation contents and measure the
results<.)
(code
\def\eq@measure{%
<code)
(.if an override value is given for indentstep in the env options, use
it<.)
(code
  \ifdim\eq@indentstep=\maxdimen \eq@indentstep\eqindentstep \fi
<code)
(.if (cseq@linewidth<cs) is nonzero at this point, it means that
the user specified a particular target width for this equation<.)
(.in that case we override the normal list of trial widths<.)
(code
  \ifdim\eq@linewidth=\z@ \else \edef\eq@linewidths{{\the\eq@linewidth}}\fi
  \begingroup \eq@params
<code)
(.even if (cshfuzz<cs) is greater than zero a box whose contents
exceed the target width by less then hfuzz still has a reported badness
value of 1000000 (pinfinitely bad<p)<.) (.because we use inf-bad
to test whether a particular trial succeeds or fails, we want to make
such boxes return a smaller badness<.) (.to this end we include an
(cshfuzz<cs) allowance in (csrightskip<cs)<.) (.in fact,
(cseq@params<cs) ensures that (cshfuzz<cs) for equations is at
least 1pt<.)
(code
  \leftskip\z@skip
%  \eqinfo
  \global\EQ@continue{\eq@trial}%
  \eq@trial % uses \eq@linewidths
  \eq@failout % will be a no-op if the trial succeeded
  \endgroup
<code)
(.(qlocal<q) parameter settings are passed outside the endgroup through
(csEQ@trial<cs)<.)
(code
  \EQ@trial
}
<code)
<para)<define)

(define(macroEQ@trial<macro)
(para(.init<.)
(code
\let\EQ@trial\@empty
<code)
<para)<define)

(define(toksEQ@continue<toks)
(para(.this is a token register used to carry trial info past a
group boundary with only one global assignment<.)
(code
\newtoks\EQ@continue
<code)
<para)<define)

(define(macroEQ@widths<macro)
(para
(.this is used for storing the actual line-width info of the equation
contents after breaking<.)
(code
\let\EQ@widths\@empty
<code)
<para)
<define)

(define(macroeq@linewidths<macro)
(para(.this is the list of target widths for line breaking<.)
(code
\def\eq@linewidths{\displaywidth\linewidth\columnwidth}
<code)
<para)<define)

(define(macroeq@trial<macro)
(para
(.the (cseq@trial<cs) function tries each candidate
line width in (cseq@linewidths<cs) until an equation layout is found
that yields satisfactory line breaks<.)
(code
\def\eq@trial{%
  \ifx\@empty\eq@linewidths
    \global\EQ@continue{}%
  \else
    \iffalse{\fi \@xp\eq@trial@a \eq@linewidths}%
  \fi
  \the\EQ@continue
}
<code)
<para)<define)

(define(macroeq@trial@a<macro)
(para(.the (cseq@trial@a<cs) function reads the leading line
width from (cseq@linewidths<cs); if the new line width is greater
than the previous one, start running trials with it; otherwise do
nothing with it<.)
(.finally, run a peculiar (csedef<cs) that leaves
(cseq@linewidths<cs) redefined to be the tail of the list<.)
(.if we succeed in finding satisfactory line breaks
for the equation, we will reset (csEQ@continue<cs) in such a
way that it will terminate the current trials<.)
(.an obvious branch here would be to check whether the width of
(csEQ@copy<cs) is less than (cseq@linewidth<cs) and go immediately
to the one-line case if so<.)
(.however, if the equation contains more than one RHS, by
default each additional RHS starts on a new line[mdash][ie], we want
the ladder layout anyway<.)
(.so we choose the initial trial on an assumption of multiple lines
and leave the one-line case to fall out naturally at a later point<.)
(code
\def\eq@trial@a#1{%
  \dim@c#1\relax
\debugwr{trial-A: width #1 (\the\dim@c)}%
  \ifx T\eq@frame \eq@frame@adjust\dim@c \fi
  \ifdim\dim@c>\eq@linewidth
    \eq@linewidth\dim@c \eq@freewidth\eq@linewidth
    \if@eq@number
      \advance\eq@freewidth-\eqnumsep
      \advance\eq@freewidth-\wd\EQ@numbox
    \fi
    \let\eq@trial@b\eq@trial@d
    \csname eq@try@layout@\eq@layout\endcsname
  \fi
  \edef\eq@linewidths{\iffalse}\fi
}
<code)
<para)<define)

(define(macroeq@try@layout@?<macro)
(para
(.this is a branching function used to choose a suitable layout if
the user didn't specify one in particular<.)
(code
\@namedef{eq@try@layout@?}{%
  \let\eq@trial@b\eq@trial@c
  \if\EQ@hasLHS
\debugmsg{trial-A: LHS present (\the\eq@wdL)}%
    \ifdim\eq@wdL>\eq@linewidth
\debugwr{trial-A: LHS > linewidth}%
<code)
(.find the total width of the RHS<.)
(.if it is relatively short, a step layout is the thing to try<.)
(code
       \dim@a\wd\EQ@copy \advance\dim@a-\eq@wdL
       \ifdim\dim@a<.25\eq@linewidth \eq@try@layout@S
       \else \eq@try@layout@l
       \fi
    \else
      \ifdim\eq@wdL>.7\eq@linewidth
\debugmsg{trial-A: LHS > .7 linewidth (linewidth=\the\eq@linewidth)}%
        \eq@try@layout@D
      \else
\debugmsg{trial-A: LHS not extraordinarily wide}%
        \eq@try@layout@L
      \fi
    \fi
  \else
\debugwr{trial-A: No LHS here}%
<code)
(.try one-line layout first, then step layout<.)
(code
    \eq@try@layout@iS
  \fi
}
<code)
<para)
<define)

(define(macroeq@trial@done<macro)
(para
(.success<.)
(code
\def\eq@trial@done{%
\debugmsg{End trial: Success!}%
  \let\eq@failout\relax
}
<code)
<para)
<define)

(define(macroeq@trial@init<macro)
(para
(.this is called from (cseq@trial@b<cs) to initialize or
re-initialize certain variables as needed when running one or more
trials at a given line width<.)
(.by default assume success, skip the fallback code<.)
(code
\def\eq@trial@init{\global\let\EQ@fallback\eq@nextlayout}
<code)
<para)
<define)

(define(macroeq@trial@save<macro)
(para
(.save the parameters of the current trial<.)
(code
\def\eq@trial@save#1{%
\debug \def\@elt{^^J||== \space}\let\@endelt\@empty\debugmsg{trial info:\eq@measurements}\debugmsg{bounding box: \the\eq@wdT x\the\eq@vspan^^J}%
  \let\@elt\relax \let\@endelt\relax
\gubed
  \xdef#1{%
    \eq@linewidth\the\eq@linewidth \eq@freewidth\the\eq@freewidth
    \eq@lines\the\eq@lines \eq@badness\the\eq@badness
    \def\@nx\eq@badline{\eq@badline}%
    \eq@wdL\the\eq@wdL \eq@wdT\the\eq@wdT \eq@sidespace\the\eq@sidespace
    \eq@vspan\the\eq@vspan \eq@dp\the\eq@dp \eq@firstht\the\eq@firstht
    \def\@nx\eq@layout{\eq@layout}%
    \def\@nx\eq@parshape{\@parshape}%
    \def\@nx\eq@measurements{\eq@measurements}%
    \def\@nx\adjust@rel@penalty{\adjust@rel@penalty}%
    \def\@nx\eq@shiftnumber{\eq@shiftnumber}%
  }%
}
<code)
<para)
<define)

(define(macroeq@recalc<macro)
(para
(.calculate (cseq@wdT<cs) et cetera<.)
(code
\def\eq@recalc{%
  \eq@wdT\z@ \eq@vspan\z@skip \eq@badness\z@
  \let\@elt\eq@recalc@a \eq@measurements \let\@elt\relax
  \ifdim\eq@wdT<\eq@linewidth
    \eq@sidespace\eq@linewidth \advance\eq@sidespace -\eq@wdT
    \divide\eq@sidespace\tw@
  \else
    \eq@sidespace\z@
  \fi
}
<code)
<para)
<define)

(define(macroeq@recalc@a<macro)
(para
(code
\def\eq@recalc@a#1x#2+#3\@endelt{%
  \eq@firstht#2\relax
  \let\@elt\eq@recalc@b
  \@elt#1x#2+#3\@endelt
}
<code)
<para)
<define)

(define(macroeq@recalc@b<macro)
(para
(code
\def\eq@recalc@b#1^^J#2,#3x#4+#5@#6\@endelt{%
  \dim@a#2\advance\dim@a#3\relax
  \ifdim\dim@a>\eq@wdT \eq@wdT\dim@a \fi
  \eq@dp#5\relax
  \advance\eq@vspan#1\advance\eq@vspan#4\advance\eq@vspan#5\relax
<code)
(.record the max badness of all the lines in (cseq@badness<cs)<.)
(code
  \ifnum#6>\eq@badness \eq@badness#6\relax\fi
}
<code)
<para)
<define)

(define(macroeq@failout<macro)
(para
(.<.)
(code
\def\eq@failout{%
\debugmsg{End trial: failout}%
  \global\let\EQ@trial\EQ@last@trial
}
<code)
<para)
<define)

(define(macroeq@frame@adjust<macro)
(para
(.if there is a frame around the equation, we need to subtract some
space from (cseq@linewidth<cs) to allow for it<.)
(code
\def\eq@frame@adjust#1{%
  \dim@a\eq@framewd \advance\dim@a\eq@framesep
  \advance#1-2\dim@a
}
<code)
<para)
<define)

(define(macroeq@layout<macro)
(para
(.a value of (qc?<qc) for (cseq@layout<cs) means that we should
deduce which layout to use by looking at the size of the components<.)
(.any other value means we have a user-specified override on the
layout<.)
(code
\def\eq@layout{?}
<code)
<para)
<define)

(define(macroeq@try@layout@D<macro)
(para
(.change the penalty before the first mathrel symbol to encourage a
break there<.)
(code
\def\eq@try@layout@D{%
  \dim@a\eq@linewidth \advance\dim@a-\eq@indentstep
  \edef\@parshape{\parshape 2
    0pt \the\eq@wdL\space \the\eq@indentstep\space \the\dim@a\relax
  }%
  \def\adjust@rel@penalty{\penalty-99 }%
  \eq@trial@b{D}{\eq@try@layout@A}%
}
<code)
<para)
<define)

(define(macroeq@try@layout@A<macro)
(para
(.in the (qqalmost-columnar<qq) layout, which is the layout of last
resort, we let all lines run to the full width and leave the adjusting
of the indents to later<.)
(code
\def\eq@try@layout@A{%
  \edef\@parshape{\parshape 1 0pt \the\eq@linewidth\relax}%
  \if\EQ@hasLHS \def\adjust@rel@penalty{\penalty-99 }\fi
  \eq@trial@b{A}{}%
}
<code)
<para)
<define)

(define(macroeq@try@layout@L<macro)
(para(.try a straight ladder layout<.)
(.preliminary filtering ensures that (cseq@wdL<cs) is less than 70%
of the current line width<.)
(code
\def\eq@try@layout@L{%
  \dim@b\eq@linewidth \advance\dim@b-\eq@wdL
  \edef\@parshape{\parshape 2 0pt \the\eq@linewidth\space
    \the\eq@wdL\space \the\dim@b\relax
  }%
  \eq@trial@b{L}{\eq@try@layout@D}%
}
<code)
<para)
<define)

(define(macroeq@try@layout@iS<macro)
(para
(code
\def\eq@try@layout@iS{%
<code)
(.in order to test whether one line is enough, we need to actually
reset the equation contents; otherwise we would fail to take
advantage of available shrink<.)
(code
  \edef\@parshape{\parshape 1 0pt \the\eq@freewidth\relax}%
  \eq@trial@b{i}{\eq@try@layout@S}%
}
<code)
<para)
<define)

(define(macroeq@try@layout@S<macro)
(para
(.in the (qqstepped<qq) layout there is no LHS, or LHS
is greater than the line width and RHS is small<.)
(.then we want to split up the equation into lines of roughly equal
width and stagger them downwards to the right, leaving a small amount of
whitespace on both sides<.)
(.but also, if there is an equation number, we want to try first a
layout that leaves room for the number<.)
(.otherwise it would nearly always be the case that the number would
get thrown on a separate line<.)
(code
\def\eq@try@layout@S{%
  \dim@b\eq@linewidth \advance\dim@b-2\eqmargin \advance\dim@b-1em%
<code)
(?about how many lines will we need if dim@b is the line width<?)
(code
  \int@a\wd\EQ@copy \divide\int@a\dim@b
<code)
(.adjust the target width by number of lines times indentstep<.)
(.we don't need to decrement (csint@a<cs) because [tex]
division is integer division with truncation<.)
(code
  \advance\dim@b-\int@a\eq@indentstep\relax
<code)
(.adjust for equation number<.)
(.but try not to leave too little room for the equation body<.)
(code
  \if@eq@number
    \ifdim\dim@b>15em%
      \advance\dim@b-\eqnumsep \advance\dim@b-\wd\EQ@numbox
    \fi
  \fi
<code)
(.now some hand-waving to set up the parshape<.)
(code
  \int@b\z@
  \def\@tempa{\dim}%
  \edef\@parshape{\parshape 2 0pt \the\dim@b\space
    \the\eqmargin\space\the\dim@b\relax}%
  \eq@trial@b{S}{\eq@try@layout@A}%
}
<code)
<para)<define)

(define(macroeq@try@layout@l<macro)
(para
(.this is the (qqstep-ladder<qq) layout: similar to the drop-ladder
layout but the LHS is too wide and needs to be broken up<.)
(code
\def\eq@try@layout@l{%
  \dim@a\eq@linewidth \advance\dim@a-\eq@indentstep
  \int@a\eq@wdL \divide\int@a\dim@a
  \advance\int@a\tw@
  \edef\@parshape{\parshape \number\int@a\space
    0pt \the\eq@linewidth
  }%
  \advance\int@a-\tw@
  \dim@b=2\eq@indentstep
  \dim@c\eq@linewidth \advance\dim@c-\dim@b
  \edef\@parshape{\@parshape
    \replicate{\int@a}{ \the\eq@indentstep\space\the\dim@a}%
    \space\the\dim@b\space\the\dim@c
  }%
  \eq@trial@b{l}{\eq@try@layout@A}%
}
<code)
<para)
<define)

(define(macroeq@fix@lastline<macro)
(para (.remove parfillskip from the last line box<.)
(code
\def\eq@fix@lastline{%
  \setbox\tw@\lastbox \dim@b\wd\tw@
  \eq@dp\dp\tw@
<code)
(.remove (csparfillskip<cs) but retain (csrightskip<cs)<.)
(.need to keep the original line width for later shrink testing<.)
(code
  \nointerlineskip\hbox to\dim@b{\unhbox\tw@
    \skip@c\lastskip \unskip\unskip\hskip\skip@c
  }%
}
<code)
<para)
<define)

(define(macroeq@trial@b<macro)
(para
(.by default this just runs (cseq@trial@c<cs); [cf]
(cseq@trial@d<cs)<.)
(code
\def\eq@trial@b{\eq@trial@c}
<code)
<para)
<define)

(define(macroeq@trial@c<macro)
(para
(.run the equation contents through the current parshape<.)
(code
\def\eq@trial@c#1#2{%
\message{^^J}\debugwr{Trying layout "#1" with parshape^^J||== \space\@xp\@gobble\@parshape}%
  \begingroup
  \eq@trial@init
  \def\eq@layout{#1}%
  \setbox\z@\vbox{%
    \hfuzz\maxdimen
    \eq@trial@p % run the given parshape
    \if\@Not{\eq@badline}%
      \eq@trial@save\EQ@trial
<code)
(.if there is a number, try the same parshape again with adjustments
to make room for the number<.)
(code
      \if@eq@number \if i\eq@layout \else\eq@retry@with@number \fi\fi
      \if L\eq@layout \eq@check@density
      \else
        \if\@Not{\eq@badline}%
          \aftergroup\@gobbletwo
          \global\EQ@continue{\eq@trial@done}%
        \fi
      \fi
    \else
      \eq@trial@save\EQ@last@trial
    \fi
  }%
  \EQ@fallback{#2}%
  \endgroup
}
<code)
<para)
<define)

(define(macroeq@check@density<macro)
(para
(code
\def\eq@check@density{%
  \if\@Or{\@Not\EQ@hasLHS}{\eq@shortLHS}%
    \aftergroup\@gobbletwo % cancel the \EQ@fallback code
    \global\EQ@continue{\eq@trial@done}%
  \else
    \if\eq@dense@enough
      \aftergroup\@gobbletwo % cancel the \EQ@fallback code
      \global\EQ@continue{\eq@trial@done}%
    \fi
  \fi
}
<code)
<para)
<define)

(define(macroeq@retry@with@number<macro)
(para
(code
\def\eq@retry@with@number{%
  \ifdim\eq@wdT>\eq@freewidth \eq@retry@with@number@a \fi
}
<code)
<para)
<define)

(define(macroeq@shiftnumber<macro)
(para
(code
\let\eq@shiftnumber\@False
<code)
<para)
<define)

(define(macroeq@retry@with@number@a<macro)
(para
(code
\def\eq@retry@with@number@a{%
  \adjust@for@number % depends on number placement
\message{^^J}\debugwr{Retrying (to make room for the number) with parshape^^J||== \space\@xp\@gobble\@parshape}%
  \nointerlineskip
  \edef\eq@prev@lines{\the\eq@lines}%
  \eq@trial@p
<code)
(.if fitting in the equation number increased the number of lines by
more than one, shift the number<.)
(code
  \int@b\eq@prev@lines \advance\int@b\@ne
  \ifnum\eq@lines>\int@b
    \let\eq@shiftnumber\@True
  \else
    \if\@Not{\eq@badline}%
      \let\eq@shiftnumber\@False
      \eq@trial@save\EQ@trial
    \else
      \let\eq@shiftnumber\@True
    \fi
  \fi
}
<code)
<para)
<define)

(define(macroadjust@for@number<macro)
(para
(.adjust a previously proven parshape to see if it can accommodate an
equation number<.)
(.store the max allowable line length (pafter subtracting the room
required for the equation number<p) in (cseq@freewidth<cs) for
reference<.)
(code
\def\adjust@for@number{%
  \dim@e\eq@freewidth
  \@xp\let\@xp\adjust@for@number@b
    \csname adjust@for@number@\eqnumside\eqnumplace\endcsname
  \@xp\adjust@for@number@a\@parshape
}
<code)
<para)
<define)

(define(macroadjust@for@number@a<macro)
(para
(code
\def\adjust@for@number@a#1 #2\relax{%
  \edef\@parshape{#1}%
  \adjust@for@number@b#2 @ @ \relax
}
<code)
<para)
<define)

(define(macroadjust@for@number@LT<macro)
(para
(.left-top number<.)
(code
\def\adjust@for@number@LT#1 #2 {%
  \ifx @#1\edef\@parshape{\@parshape\relax}%
    \@xp\@gobble
  \else
    \dim@a#1\advance\dim@a\dim@d
    \dim@b#2\advance\dim@b-\dim@d
    \edef\@parshape{\@parshape\space\the\dim@a\space\the\dim@b}%
  \fi
  \adjust@for@number@LT
}
<code)
<para)
<define)

(define(macroadjust@for@number@LM<macro)
(para
(code
\let\adjust@for@number@LM\adjust@for@number@LT
<code)
<para)
<define)

(define(macroadjust@for@number@RM<macro)
(para
(code
\def\adjust@for@number@RM#1 #2 {%
  \ifx @#1\edef\@parshape{\@parshape\relax}%
    \@xp\@gobble
  \else
<code)
(.taking indent [arg1] and line width [arg2], see if their sum
exceeds (cseq@freewidth<cs)<.)
(.if so, subtract the difference from the line width; but the line
width must be at least some minimum value that will keep the line
from being left entirely blank<.)
(code
    \dim@c#2\relax
    \dim@b\eq@freewidth
    \advance\dim@b-#1\advance\dim@b-\dim@c
    \ifdim\dim@b<\z@ \advance\dim@c\dim@b
      \ifdim\dim@c<\p@ \dim@c\p@\relax \fi
    \fi
    \edef\@parshape{\@parshape\space#1 \the\dim@c}%
  \fi
  \adjust@for@number@RM
}
<code)
<para)
<define)

(define(macroeq@trial@p<macro)
(para
(code
\def\eq@trial@p{%
  \@parshape %
  \eq@dump@box\unhcopy\EQ@copy
  {\@@par}% leave \parshape readable
  \eq@lines\prevgraf
\debugmsg{Number of lines: \number\eq@lines}%
  \eq@fix@lastline
  \let\eq@badline\@False
  \if i\eq@layout \ifnum\eq@lines>\@ne \let\eq@badline\@True \fi\fi
  \eq@curline\eq@lines % loop counter for eq@measure@lines
  \let\eq@measurements\@empty
  \eq@ml@record@indents
  \eq@measure@lines
  \eq@recalc
}
<code)
<para)
<define)

(define(macroadjust@rel@penalty<macro)
(para
(.normally this is a no-op<.)
(code
\let\adjust@rel@penalty\@empty
<code)
<para)
<define)

(define(macroeq@shortLHS<macro)
(para
(.test to see if we need to apply the (cseq@dense@enough<cs) test<.)
(code
\def\eq@shortLHS{\ifdim\eq@wdL>.44\eq@wdT 1\else 0\fi 0}
<code)
<para)
<define)

(define(macroeq@nextlayout<macro)
(para
(.in the fallback case cancel the current group to avoid unnecessary
group nesting (pwith associated save-stack cost, [etc]<p)<.)
(code
\def\eq@nextlayout#1{% 
  \endgroup
\debugwr{Nope ... that ain't gonna work.}%
  \begingroup #1%
}
<code)
<para)
<define)

(define(macroeq@trial@d<macro)
(para
(.run a trial but skip the fallback code<.)
(.this is what we want when the user has specified a particular
layout<.)
(code
\def\eq@trial@d#1#2{\eq@trial@c{#1}{}}
<code)
<para)
<define)

(define(macroEQ@fallback<macro)
(para
(.a switching function used in (cseq@trial@c<cs)<.)
(code
\let\EQ@fallback\@empty
<code)
<para)
<define)

(define(macroeq@ml@record@indents<macro)
(para
(.plunk the parshape's indent values into an array for easy access
when constructing (cseq@measurements<cs)<.)
(code
\def\eq@ml@record@indents{%
  \int@a\z@
  \def\@tempa{%
    \advance\int@a\@ne
    \@xp\edef\csname eq@i\number\int@a\endcsname{\the\dim@a}%
    \ifnum\int@a<\int@b \afterassignment\@tempb \fi
    \dim@a
  }%
  \def\@tempb{\afterassignment\@tempa \dim@a}%
  \def\@tempc##1##2 {\int@b##2\afterassignment\@tempa\dim@a}%
  \@xp\@tempc\@parshape
}
<code)
<para)
<define)

(define(macro@endelt<macro)
(para
(.this is a scan marker<.)
(.it should get a non-expandable definition<.)
(.it could be (csrelax<cs), but let's try a chardef instead<.)
(code
\chardef\@endelt=`\?
<code)
<para)
<define)

(define(macroeq@measurements<macro)
(para
(.this is similar to a parshape spec but for each line we record more
info: space above, indent, width x height + dp, and badness<.)
(code
\def\eq@measurements{%
  \@elt 4.5pt/5.0pt,66.0ptx6.8pt+2.4pt@27\@endelt
  ...
}
<code)
<para)
<define)

(define(macroeq@measure@lines<macro)
(para(.loop through the list of boxes to measure things like total
height (pincluding interline stretch<p), [etc]<.) (.we check the
actual width of the current line against the natural width [mdash]
after removing rightskip [mdash] in case the former is
(emphless<emph) than the latter because of shrinkage<.) (.in that
case we do not want to use the natural width for RHS-max-width because
it might unnecessarily exceed the right margin<.)
(code
\def\eq@measure@lines{%
  \let\eq@ml@continue\eq@measure@lines
  \setbox\tw@\lastbox \dim@b\wd\tw@ % find target width of line
  \setbox\z@\hbox to\dim@b{\unhbox\tw@}% check for overfull
  \eq@badness\badness
  \ifnum\eq@badness<\inf@bad \else \let\eq@badline\@True \fi
  \eq@ml@a \eq@ml@continue
}
<code)
<para)
<define)

(define(macroeq@ml@a<macro)
(para
(code
\def\eq@ml@a{%
  \setbox\tw@\hbox{\unhbox\z@ \unskip}% find natural width
\debug\ifnum\eq@badness<\inf@bad\else\debugmsg{!?! Overfull: \the\wd\tw@ >\the\dim@b}\fi\gubed
<code)
(?is actual width less than natural width<?)
(code
  \ifdim\dim@b<\wd\tw@ \dim@a\dim@b  % shrunken line
  \else                \dim@a\wd\tw@ % OK to use natural width
  \fi
<code)
(.if there's no aboveskip, assume we've reached the top of the
equation<.)
(code
  \skip@a\lastskip \unskip \unpenalty
  \ifdim\skip@a=\z@
    \let\eq@ml@continue\relax % end the recursion
  \else
    % Sum repeated vskips if present
    \def\@tempa{%
      \ifdim \lastskip=\z@
      \else \advance\skip@a\lastskip \unskip\unpenalty \@xp\@tempa
      \fi
    }%
  \fi
  \edef\eq@measurements{\@elt
    \the\skip@a\space^^J% extra space to facilitate extracting only the
                        % dimen part later
    \csname eq@i%
      \ifnum\eq@curline<\parshape \number\eq@curline
      \else\number\parshape
      \fi
    \endcsname,\the\dim@a x\the\ht\tw@+\the\dp\tw@ @\the\eq@badness\@endelt
    \eq@measurements
  }%
  \advance\eq@curline\m@ne
  \ifnum\eq@curline=\z@ \let\eq@ml@continue\relax\fi
}
<code)
<para)
<define)

(define(macroeq@ml@vspace<macro)
(para
(.handle an embedded vspace<.)
(code
\def\eq@ml@vspace{%
  \global\advance\eq@vspan\lastskip \unskip\unpenalty
  \ifdim\lastskip=\z@ \else \@xp\eq@ml@vspace \fi
}
<code)
<para)
<define)

(define(macroeq@dense@enough<macro)
(para
(code
\def\eq@dense@enough{%
  \ifnum\eq@lines<\thr@@ \@True
  \else
    \ifdim\eq@wdL >.7\eq@wdT \@False
    \else \@xp\@xp\@xp\eq@dense@enough@a
    \fi
  \fi
}
<code)
<para)
<define)

(define(macrotrue@false@true<macro)
(para
(code
\def\true@false@true{\fi\fi\iftrue\iffalse\iftrue}
<code)
<para)
<define)

(define(macrofalse@false@false<macro)
(para
(code
\def\false@false@false{\fi\fi\iffalse\iffalse\iffalse}
<code)
<para)
<define)

(define(macrofalse@true@false<macro)
(para
(code
\def\false@true@false{\fi\fi\iffalse\iftrue\iffalse}
<code)
<para)
<define)

(define(macroeq@density@factor<macro)
(para
(.this number specifies, for the ladder layout, how much of the
equation's bounding box should contain visible material rather than
whitespace<.)
(.if the amount of visible material drops below this value, then we
switch to the drop-ladder layout<.)
(.the optimality of this factor is highly dependent on the equation
contents; .475 was chosen as the default just because it worked well
with the sample equation, designed to be as average as possible, that I
used for testing<.)
(code
\def\eq@density@factor{.475}
<code)
<para)
<define)

(define(macroeq@dense@enough@a<macro)
(para
(.calculate whether there is more
visible material than whitespace within the equation's bounding box<.)
(.sum up the actual line widths and compare to the total
(qqarea<qq) of the bounding box<.)
(.but if we have an extremely large number of lines, fall back to an
approximate calculation that is more conservative about the danger of
exceeding (csmaxdimen<cs)<.)
(code
\def\eq@dense@enough@a{%
  \@True \fi
  \ifnum\eq@lines>\sixt@@n
    \eq@dense@enough@b
  \else
    \dim@b\z@ \let\@elt\eq@delt \eq@measurements
    \dim@c\eq@density@factor\eq@wdT \multiply\dim@c\eq@lines
\debugwr{black \the\dim@b/\eq@density@factor total \the\dim@c}%
    \ifdim\dim@b>\dim@c \true@false@true \else \false@false@false \fi
  \fi
}
<code)
<para)
<define)

(define(macroeq@delt<macro)
(para
(.args are space-above, indent, width, height, depth, badness<.)
(code
\def\eq@delt#1^^J#2,#3x#4+#5@#6\@endelt{\advance\dim@b#3\relax}%
<code)
<para)
<define)

(define(macroeq@dense@enough@b<macro)
(para
(.this is an approximate calculation used to keep from going over
(csmaxdimen<cs) if the number of lines in our trial break is large
enough to make that a threat<.)
(.if l, t, n represent left-side-width, total-width, and number of
lines, the formula is
(literal
l/t < .4n/(.9n-1)
<literal)
or equivalently, since rational arithmetic is awkward in [tex]:
b
(literal
l/t < 4n/(9n-10)
<literal)
<.)
(code
\def\eq@dense@enough@b{%
  \int@b\eq@wdT \divide\int@b\p@
  \dim@b\eq@wdL \divide\dim@b\int@b
  \dim@c\eq@lines\p@ \multiply\dim@c\f@ur
  \int@b\eq@lines \multiply\int@b 9 \advance\int@b -10%
  \divide\dim@c\int@b
\debugwr{l/t \the\dim@b\space< \the\dim@c\space 4n/(9n-10)?}%
  \ifdim\dim@b<\dim@c \true@true@true \else \false@true@false \fi
}
<code)
<para)
<define)

(define(macroadjust@parshape<macro)
(para
(.varies depending on the layout<.)
(code
\def\adjust@parshape#1{%
  \@xp\adj@psh@a \csname adjust@parshape@#1@\eq@layout\endcsname
}
<code)
<para)
<define)

(define(macroadj@psh@a<macro)
(para
(code
\def\adj@psh@a#1{%
  \ifx\@@undefined#1\relax
\debugmsg{UNDEFINED: \string#1}%
  \else \@xp#1\eq@parshape
  \fi
}
<code)
<para)
<define)

(define(macroadj@psh@b<macro)
(para
(code
\def\adj@psh@b#1{%
\debugmsg{Adjusting parshape (\eqindent\if@eq@number\eqnumside\eqnumplace\fi @\eq@layout)}%
  \edef\eq@parshape{\parshape \number\eq@lines}%
  \let\@elt#1\eq@measurements \let\@elt\relax
  \edef\eq@parshape{\eq@parshape\relax}%
\debugmsg{\eq@parshape}%
  \leftskip\z@skip
}
<code)
<para)
<define)

(define(macroadjust@parshape@C@L<macro)
(para
(.here we typically have a parshape that looks like this:
(literal
\parshape 2 0pt 164.44438pt 64.02786pt 100.41652pt
<literal)
<.)
(.and (csleftskip<cs) holds the value of our recent calculations
for centering<.)
(.so we just need to add leftskip to both of the indents<.)
(code
\def\adjust@parshape@C@L#1 #2 #3 #4 #5\relax{%
  \dim@a\leftskip \advance\dim@a#4\relax
  \edef\eq@parshape{#1 \the\leftskip\space#3 \the\dim@a\space#5\relax}%
\debugmsg{\eq@parshape}%
  \leftskip\z@skip
}
<code)
<para)
<define)

(define(macroadjust@parshape@C@D<macro)
(para
(.in this case we want to see how much space there is left over and
increase the indents if there is room to do so<.)
(.(csleftskip<cs) holds the current calculated indent value for
centering<.)
(.parshape is something of the form
(literal
\parshape 2 0pt 91.25015pt 10.0pt 185.0pt
<literal)
<.)
(code
\def\adjust@parshape@C@D#1 #2 #3 #4 #5\relax{%
  \dim@b\eq@linewidth \advance\dim@b-\eq@wdT
\debugmsg{linewidth - wdT = \the\eq@linewidth\space- \the\eq@wdT\space=\the\dim@b}%
  \advance\dim@b-\eqmargin
\debugmsg{ - eqmargin (\the\eqmargin) = \the\dim@b}%
  \advance\dim@b#4\relax
\debugmsg{ + #4 = \the\dim@b}%
<code)
(.this gives us the starting point of the first line<.)
(code
  \dim@a\eqmargin
  \adj@psh@b\C@D@elt
}
<code)
<para)
<define)

(define(macroC@D@elt<macro)
(para
(code
\def\C@D@elt#1^^J#2,#3x#4\@endelt{%
  \edef\eq@parshape{\eq@parshape\space \the\dim@a\space #3}%
  \dim@a\dim@b % use dim@b for all remaining lines
}
<code)
<para)
<define)

(define(macroadjust@parshape@C@S<macro)
(para
(.suppose that we have dissimilar line widths, such as
(literal
  xxxxxxxxxx
    yyyyyyyyyyyyyyyy
    zzzzzzz
<literal)
<.)
(?is it better rendered like this:
(literal
  xxxxxxxxxx
    yyyyyyyyyyyyyyyy
               zzzzzzz
<literal)
<?)
(.consider some other combinations of y lines: here all about the same
width:
(literal
  xxxxxxxxxx
    yyyyyyyyyyyyyyyy
     yyyyyyyyyyyyyyyy
      yyyyyyyyyyyyyyyy
       yyyyyyyyyyyyyyyy
                  zzzzzzz
<literal)
and here with disparate widths:
(literal
  xxxxxxxxxx
    yyyyyyyyy
     yyyyyyyyyyyyyyyyyyyy
      yyyyy
       yyyyyyyyyyyyyyyy
                  zzzzzzz
<literal)
<.)
(.one might ask if that last one should be
(literal
  xxxxxxxxxx
    yyyyyyyyy
     yyyyyyyyyyyyyyyyyyyy
                     yyyyy
                      yyyyyyyyyyyyyyyy
                                 zzzzzzz
<literal)
<.)
(.it seems that the answer is no: too costly<.)<para)
(para
(.ignore the current parshape and rebuild from
(cseq@measurements<cs)<.)
(code
\def\adjust@parshape@C@S#1 #2 #3 #4 #5\relax{%
  \dim@b#4\relax % normally = \eqmargin
  \dim@d\eq@linewidth \advance\dim@d-\eq@wdT
  \ifdim\dim@d<2\dim@b
    \dim@c\leftskip
    \advance\dim@d-\dim@c
  \else \advance\dim@d-2\dim@b
    \dim@c\dim@b
  \fi
  \advance\dim@d-\dim@c \advance\dim@d\dim@b
  \int@a\eq@lines \advance\int@a\m@ne
  \ifnum\int@a>\@ne \divide\dim@d\int@a \fi
\debugmsg{dim@d after dividing: \the\dim@d}%
  \adj@psh@b\C@S@elt
}
<code)
<para)
<define)

(define(macroC@S@elt<macro)
(para
(code
\def\C@S@elt#1^^J#2,#3x#4+#5@#6\@endelt{%
  \edef\eq@parshape{\eq@parshape\space \the\dim@c\space #3}%
  \advance\dim@c\dim@d
}
<code)
<para)
<define)

(define(macroadjust@parshape@CRM@D<macro)
(para
(.in this case we want to see how much space there is left over and
increase the indents if there is room to do so<.)
(.(csleftskip<cs) holds the current calculated indent value for
centering<.)
(.parshape is something of the form
(literal
\parshape 2 0pt 91.25015pt 10.0pt 185.0pt
<literal)
<.)
(code
\def\adjust@parshape@CRM@D#1 #2 #3 #4 #5\relax{%
  \dim@b\eq@linewidth \advance\dim@b-\eq@wdT
\debugmsg{linewidth - wdT = \the\eq@linewidth\space- \the\eq@wdT\space=\the\dim@b}%
  \advance\dim@b-\eqnumsep \advance\dim@b-\wd\EQ@numbox
\debugmsg{ - numsep (\the\eqnumsep) - numwd (\the\wd\EQ@numbox) = \the\dim@b}%
  \advance\dim@b#4\relax
\debugmsg{ + #4 = \the\dim@b}%
<code)
(.this gives us the starting point of the first line<.)
(code
  \dim@a\eqmargin
  \adj@psh@b\C@D@elt
}
<code)
<para)
<define)

(define(macroadjust@parshape@CRM@L<macro)
(para
(code
\def\adjust@parshape@CRM@L{\adjust@parshape@C@L}
<code)
<para)
<define)

(define(macroadjust@parshape@CRM@S<macro)
(para
(.see the C@S case<.)
(code
\def\adjust@parshape@CRM@S#1 #2 #3 #4 #5\relax{%
  \dim@b#4\relax % normally = \eqmargin
  \dim@d\eq@linewidth \advance\dim@d-\eq@wdT
  \advance\dim@d-\eqnumsep \advance\dim@d -\wd\EQ@numbox
  \ifdim\dim@d<\dim@b \dim@c\leftskip
  \else \dim@c\dim@b
  \fi
  \advance\dim@d-\dim@c \advance\dim@d\dim@b
  \int@a\eq@lines \advance\int@a\m@ne
  \ifnum\int@a>\@ne \divide\dim@d\int@a \fi
\debugmsg{dim@d after dividing: \the\dim@d}%
  \adj@psh@b\C@S@elt
}
<code)
<para)
<define)

(para
(.needs work<.)
(code
\def\adjust@parshape@CRM@A#1\relax{\debugmsg{CRM@A: #1}}
\def\adjust@parshape@CRM@l#1\relax{\debugmsg{CRM@l: #1}}
<code)
<para)

(define(macroeq@parshape<macro)
(para
(code
\let\eq@parshape\@empty
<code)
<para)
<define)

(define(macroeq@params<macro)
(para(.the interline spacing and penalties in (cseq@params<cs)
are used during both preliminary line breaking and final typesetting<.)
(code
\def\eq@params{%
  \baselineskip\eqlinespacing
  \lineskip\eqlineskip \lineskiplimit\eqlineskiplimit
<code)
(.forbid absolutely a pagebreak that separates the first line or last
line of a multiline equation from the rest of it<.) (.or in other
words: no equation of three lines or less will be broken at the bottom
of a page; instead it will be moved whole to the top of the next
page<.) (.if you really really need a page break that splits the
first or last line from the rest of the equation, you can always fall
back to(cspagebreak<cs), I suppose9<.)
<para)
(para(code
  \clubpenalty\@M \widowpenalty\@M \interlinepenalty\eqinterlinepenalty
  \linepenalty199 \exhyphenpenalty9999
<code)
(.for equations, hfuzz should be at least 1pt<.)
(.but we have to fake it a little because we are running the equation
through [tex]'s paragrapher<.)
(.in our trials we use minus 1pt in the rightskip rather than hfuzz;
and we must do the same during final breaking of the equation, otherwise
in borderline cases [tex] will use two lines instead of one when our
trial indicated that one line would be enough<.)
(code
  \ifdim\hfuzz<\p@ \hfuzz\p@ \fi
  \rightskip\z@\@plus\columnwidth \@minus\hfuzz \hfuzz\z@
  \parfillskip\z@skip
  \if\eq@centerlines
<code)
(.this adds the stretch-or-shrink part of rightskip to leftskip<.)
(.generally speaking this only makes sense for parshapes where all the
indents are zero<.)
(code
    \advance\leftskip\rightskip \advance\leftskip -1\rightskip
  \fi
<code)
(.make sure we skip [tex]'s preliminary line-breaking pass to save
processing time<.)
(code
  \tolerance9999 \pretolerance\m@ne
}
<code)
<para)<define)
<section)

(section(titleequation layout options<title)
(para(.using the notation C centered, I indented (papplied to
the equation body<p), T top, B bottom, M
middle, L left, R right (papplied to the equation number<p),
the commonly used equation types are C, CRM, CRB, CLM, CLT,
I, IRM, IRB, ILM, ILT<.) (.in other words, CLM stands for Centered equation
body with Left-hand Middle-placed equation number, and IRB stands for
Indented equation with Right-hand Bottom-placed equation number<.)
<para)

(subsection(titleCentered Right-Number Equations<title)

(define(macroeq@dump@box<macro)
(para
(.[arg1] might be (csunhbox<cs) or (csunhcopy<cs); [arg2] is
the box name<.)
(code
\def\eq@dump@box#1#2{%
%\debug@box#1%
  \noindent #1#2\setbox\f@ur\lastbox \setbox\tw@\lastbox
<code)
(.if the LHS contains shrinkable glue, in an L layout the alignment
could be thrown off if the first line is shrunk noticeably<.)
(.for the time being, disable shrinking on the left-hand side<.)
(.the proper solution requires more work (dnmjd,1999/03/17<dn)<.)
(code
  \if L\eq@layout \box\tw@ \else\unhbox\tw@\fi
  \adjust@rel@penalty \unhbox\f@ur
}
<code)
<para)
<define)

(define(macroeq@C<macro)
(para(.(eqtypeC<eqtype) Centered equation without a
number<.)
(.the amount of clear whitespace left and right, disregarding equation
number, is given by
(cseq@sidespace<cs)[mdash][ie], total is 2(cseq@sidespace<cs)<.)
(.the linewidth to use for all lines is given by
(cseq@linewidth<cs) which may, in the same way as
(cslinewidth<cs), be less than the current column width
(p(cshsize<cs)<p)<.)
(.in the following diagram (qc:<qc) represents leftskip glue and
(qc.<qc) is rightskip; and the LHS is overlaid on top of the leftskip
glue, not pushing against it<.)
(literal
            ,-----------eq@sidespace-------------.
           /                                      \
    |-----'-|                                  |---`----|
              |---wd@L---| |------max@R------|
::::|:::::::: LLLLLLLLLLLL = RRRRRRRRRRRRRR .............
::::|::::::::::::::::::::: = RRRRRRRRRRRRRRRRR ..........
::::|::::::::::::::::::::: = RR .........................
    |---------eq@linewidth------------------------------|
|--------------------------------------hsize------------|
<literal)
(code
\def\eq@C{%
\debugmsg{\eq@sidespace\the\eq@sidespace, \eq@wdT\the\eq@wdT, \eq@linewidth\the\eq@linewidth}%
  \eq@params
  \leftskip\eq@sidespace
  \adjust@parshape{C}%
  \eq@parshape
\debugwr{\string\eq@parshape:\eq@parshape}%
  \eq@topspace{\noindent}%
  \ifx F\eq@frame
  \else
    \vbox to\eq@firstht{\hbox to\z@{\eq@addframe\hss}\vss}%
  \fi
<code)
(.in borderline cases when we got one line in our preliminary trial we
have to wrap the equation in a box to ensure that it doesn't switch to
two lines due to a discrepancy in the handling of (cshfuzz<cs)<.)
(code
  \eq@dump@box\unhbox\EQ@box \@@par
}
<code)
<para)
<define)

(define(macroeq@CRB<macro)
(para(.(eqtypeCRB<eqtype) Centered equation with Right-hand,
Bottom-placed number<.) (.this might be called indirectly via the
CRM case if we have learned that there is (emphnot<emph)
enough room for the number at the middle placement location, but there
is enough room for it on the last line<.)
(code
\def\eq@CRB{%
  \if\eq@shiftnumber
    \leftskip\eq@sidespace
  \else
    \ifnum\eq@lines=\@ne
      \leftskip\eq@sidespace \advance\leftskip\eqnumsep
      \ifdim\leftskip<3\wd\EQ@numbox
        \multiply\leftskip\tw@ \divide\leftskip\thr@@
        \ifdim\leftskip<2\eqnumsep
          \leftskip\eq@sidespace \divide\leftskip\tw@
        \fi
\debugmsg{Shifting off-center: leftskip \the\leftskip}%
      \else
        \divide\leftskip\tw@
\debugmsg{Plenty of room: leftskip \the\leftskip}%
      \fi
    \fi
  \fi
  \eq@CRBa
}
<code)
(.finish the Centered equation, Right-Bottom number case<.)
(code
\def\eq@CRBa{%
<code)
(.(cseq@topspace<cs) sets (csparskip<cs) to the normal or short
above-display space, depending on where the first line of the equation
begins and the preceding text line ends<.)
(code
  \eq@topspace{\noindent}%
  \ifx F\eq@frame
  \else \vbox to\eq@firstht{\hbox to\z@{\eq@addframe\hss}\vss}%
  \fi
  \eq@params \eq@parshape
  \add@grp@label
  \eq@dump@box\unhbox\EQ@box \@@par
  \penalty\@M
  \if\eq@shiftnumber
  \else
    \lineskiplimit-\maxdimen \baselineskip\z@skip
  \fi
  \hbox to\eq@linewidth{\hfil\copy\EQ@numbox}%
}
<code)
<para)
<define)

(define(macroeq@CRM<macro)
(para(.(eqtypeCRM<eqtype) Centered equation with Right-hand,
Mid-placed number<.) (.we have a parshape in hand that gives
acceptable line breaks, but now we need to modify the overall indent
amount to achieve a centered effect<.) (.note that we calculate an
explicit indent for the left side rather than use stretchable glue to
achieve the centering<.) (.in addition, we need to find the best spot
to plug in the equation number<.)
(code
\def\eq@CRM{%
\debug
  \dim@a\eq@wdT \advance\dim@a\eqnumsep \advance\dim@a\wd\EQ@numbox
\debugmsg{\hsize\the\hsize, \eq@linewidth\the\eq@linewidth}%
\debugmsg{T+S+N = \the\eq@wdT+\the\eqnumsep+\the\wd\EQ@numbox\space= \the\dim@a}%
\debugmsg{sidespace: \the\eq@sidespace}%
\gubed
  \ifnum\eq@lines<\tw@
<code)
(.if the equation is only one line long we need to check now whether
there is enough room to add the equation number on the same line<.)
(code
    \ifdim\eq@wdT>\eq@freewidth \let\eq@shiftnumber\@True\fi
  \fi
  \rightskip\z@\@plus\eq@linewidth \parfillskip\z@skip
  \if\eq@shiftnumber
<code)
(.if the number must be shifted, there's no difference between the CRM
case and the CRB case<.)
(code
    \@xp\eq@CRB % shifted number
  \else
    \set@leftskip@for@centering
    \@xp\eq@CRMa % nonshifted number
  \fi
}
<code)
<para)<define)

(define(macroset@leftskip@for@centering<macro)
(para
(.following the calculations done by a primitive [tex] display
operation: If the space available for the equation number is
(m[geq]4N<m) (p(mN<m) the number width<p), then we can leave
the equation body centered within the columnwidth and disregard the
number width; but if the leftover space is smaller, then we shift the
body away from the number to achieve a better visual illusion of
centering<.)
(code
\def\set@leftskip@for@centering{%
  \leftskip\eq@sidespace\relax
  \ifdim\leftskip>\z@
    \ifdim\leftskip<2\wd\EQ@numbox
      \leftskip\eq@linewidth \advance\leftskip-\eq@wdT
      \advance\leftskip-\wd\EQ@numbox
      \multiply\leftskip\tw@ \divide\leftskip\thr@@
      \ifdim\leftskip<2\eqnumsep
        \leftskip\eq@freewidth \advance\leftskip-\eq@wdT
        \divide\leftskip\tw@
  \debugmsg{Off-center: leftskip = .5W = \the\leftskip}%
      \else
  \debugmsg{Off-center: leftskip = .667W = \the\leftskip}%
      \fi
    \else
  \debugmsg{Plenty of room: leftskip \the\leftskip}%
    \fi
  \fi
}
<code)
<para)
<define)


(define(macroeq@CRMa<macro)
(para(.(eqtypeCRMa<eqtype) Centered equation with Right-hand,
Mid-placed number, and we have learned that there is enough room so the
number need not be shifted<.) (.the tricky part here is placing the
number with vertical glue so that it floats properly with the equation
body even when stretch and shrink occur<.) (.if the equation is
framed, bail out and just wrap it in a box; otherwise, the vertical list
that we're aiming for is
(literal
<previous box> (prevdepth)
\predisplaypenalty
\abovedisplayskip
\baselineskip (incl adj for prevdepth) or \lineskip
\vbox to\eq@firstht{\vss} % plug in color background or frame here
\nobreak
*\vskip to top of number (with stretch/shrink)
*(nointerlineskip)
*\hbox{number}
*\nobreak
*(nointerlineskip)
*\parskip back to top of equation (with stretch/shrink?)
equation body (stack of lines)
\postdisplaypenalty
\belowdisplayskip
<literal)
<.) (.when the number is not present, or when it fits on the last
line of the equation, then the starred lines can be replaced with the
simpler
(literal
(nointerlineskip)
\parskip-\eq@firstht
<literal)
<.)
(.finish a Centered equation, Right-Middle number case<.)
(code
\def\eq@CRMa{%
  \eq@topspace{\vskip\parskip}%
  \vbox to\eq@firstht{%
    \ifx F\eq@frame
    \else
      \moveright\leftskip\hbox to\z@{\eq@addframe\hss}%
    \fi
    \vss}%
  \penalty\@M
  \skip@c\eq@vspan
  \advance\skip@c-\ht\EQ@numbox \advance\skip@c-\dp\EQ@numbox
  \divide\skip@c\tw@
  \parskip-\skip@c
  \advance\parskip-\ht\EQ@numbox \advance\parskip-\dp\EQ@numbox
  \advance\skip@c-\eq@firstht
  \vskip\skip@c \nointerlineskip
  \hbox to\hsize{\hfil\copy\EQ@numbox}%
  \nobreak
  \eq@params
  \adjust@parshape{CRM}%
  \eq@parshape
<code)
(.the special value of (csparskip<cs) is used here<.)
(code
  \nointerlineskip \noindent\add@grp@label \eq@dump@box\unhbox\EQ@box %
%  \tracingparagraphs=2 \@@par \tracingparagraphs=0%
  \@@par
}
<code)
<para)
<define)
<subsection)

(subsection(titleCentered Left-Number Equations<title)
(define(macroeq@CLM<macro)
(para(.(eqtypeCLM<eqtype) Centered equation with Left-hand,
Mid-placed number<.) (.we have a parshape in hand that gives
acceptable line breaks, but now we need to modify the overall indent
amount to achieve a centered effect<.)
(code
\def\eq@CLM{%
  \ifnum\eq@lines=\@ne
    \ifdim\eq@freewidth<\wd\EQ@box
      \let\eq@shiftnumber\@True
    \fi
  \fi
  \if\eq@shiftnumber
    \eq@CLT
  \else
<code)
(.the calculations here for the CLM case are particularly thorny and I
haven't worked out the details yet to my satisfaction [mdash] this is
just a first stab at it [mjd,1997/10/22]<.)
(code
    \leftskip\eq@sidespace \advance\leftskip\eqnumsep
    \ifdim\leftskip<3\wd\EQ@numbox
      \multiply\leftskip\tw@ \divide\leftskip\thr@@
    \else
      \divide\leftskip\tw@
    \fi
    \ifdim\leftskip>\eq@hshift \advance\leftskip-\eq@hshift
    \else \leftskip\z@skip
    \fi
    \rightskip\z@\@plus\eq@linewidth \parfillskip\z@skip
    \ifnum\eq@lines>\@ne
      \eq@topspace{\vskip\parskip}%
    \else
      \vskip\abovedisplayskip
    \fi
    \vbox to\eq@firstht{%
      \ifx F\eq@frame
      \else
        \moveright\leftskip\hbox to\z@{\eq@addframe\hss}%
      \fi
      \vss}%
    \penalty\@M
    \skip@c\eq@vspan \advance\skip@c-\ht\EQ@numbox
    \advance\skip@c-\dp\EQ@numbox \divide\skip@c\tw@
    \parskip-\skip@c
    \advance\parskip-\ht\EQ@numbox \advance\parskip-\dp\EQ@numbox
    \advance\skip@c-\eq@firstht
    \vskip\skip@c \nointerlineskip
    \copy\EQ@numbox
    \nobreak
    \eq@params \eq@parshape
%\debug@box\EQ@box\tracingparagraphs\@ne\debug@para
<code)
(.the special value of (csparskip<cs) is used here<.)
(code
    \nointerlineskip \noindent\add@grp@label \eq@dump@box\unhbox\EQ@box \@@par
  \fi
}
<code)
<para)
<define)
(define(macroeq@CLT<macro)
(para(.(eqtypeCLT<eqtype) Centered equation with Left-hand,
Top-placed number<.)
(code
\def\eq@CLT{%
  \if\eq@shiftnumber
    \leftskip\eq@sidespace \divide\leftskip\tw@
  \else
    \leftskip\eq@sidespace \advance\leftskip\eqnumsep
    \ifnum\eq@lines=\@ne
      \ifdim\eq@sidespace<2\wd\EQ@numbox
        \multiply\leftskip\tw@ \divide\leftskip\thr@@
%\debugmsg{Shifting off-center: leftskip \the\leftskip}%
      \else
        \divide\leftskip\tw@
%\debugmsg{Plenty of room: leftskip \the\leftskip}%
      \fi
    \else
      \divide\leftskip\tw@
    \fi
  \fi
  \eq@CLTa
}
<code)
(.set (csparskip<cs) to the normal or short above-display space,
depending on where the first line of the equation begins and the
preceding text line ends<.)
(code
\def\eq@CLTa{%
  \vskip\abovedisplayskip
  \copy\EQ@numbox \penalty\@M
  \if\eq@shiftnumber \else \kern-\eq@firstht \nointerlineskip \fi
  \noindent
  \ifx F\eq@frame
  \else \vbox to\eq@firstht{\hbox to\z@{\eq@addframe\hss}\vss}%
  \fi
  \eq@params \eq@parshape
  \add@grp@label \eq@dump@box\unhbox\EQ@box\@@par
}
<code)
<para)
<define)
<subsection)

(subsection(titleIndented Right-Number Equations<title)
(para(.needs testing<.)
(code
\def\eq@IRM{\leftskip\mathindent \eq@CRMa}
\def\eq@IRB{\leftskip\mathindent \eq@CRBa}
\def\eq@I{%
  \leftskip\mathindent
  \eq@params
  \eq@topspace{\noindent}%
  \ifx F\eq@frame
  \else
    \vbox to\eq@firstht{\hbox to\z@{\eq@addframe\hss}\vss}%
  \fi
  \eq@dump@box\unhbox\EQ@box\@@par
}
<code)
<para)
<subsection)

(subsection(titleIndented Left-Number Equations<title)
(para(.needs work<.)
<para)
<subsection)
<section)

(section(titleframing an equation<title)
(para(.the (cseqframe<cs) function is called in vertical mode
with the reference point at the top left corner of the equation, including
any allowance for (csfboxsep<cs)<.) (.its arguments are the width
and height of the equation body, plus fboxsep<.)
(code
\newcommand\eqframe[2]{\framebox{\z@rule\@height#2\kern#1}}
\def\eq@addframe{%
  \hbox to\z@{\dim@a\fboxsep \advance\dim@a\fboxrule
    \kern-\dim@a
    \vbox to\z@{\kern-\dim@a
      \hbox{\eqframe{\eq@wdT}{\eq@vspan}}%
      \vss
    }%
    \hss
  }%
}
<code)
<para)
<section)

(section(titledelimiter handling<title)
(para(.the special handling of delimiters is rather complex, but
everything is driven by two motives: to mark line breaks inside
delimiters as less desirable than line breaks elsewhere, and to make it
possible to break open left-right boxes so that line breaks between
(csleft<cs) and (csright<cs) delimiters are not absolutely
prohibited<.) (.to control the extent to which line breaks will be
allowed inside delimiters, set (cseqbreakdepth<cs) to the maximum
nesting depth<.) (.depth 0 means never break inside delimiters<.)
<para)
(para(.note: (cseqbreakdepth<cs) is not implemented as a [latex]
counter because changes done by (cssetcounter<cs) [etc] are always
global<.)
<para)
(para(.it would be natural to use grouping in the implementation
[mdash] at an open delimiter, start a group and increase mathbin
penalties; at a close delimiter, close the group<.) (.but this gives us
trouble in situations like the (envarray<env) environment, where a
close delimiter might fall in a different cell of the (cshalign<cs)
than the open delimiter<.) <para)
(para(.ok then, here's what we want the various possibilities to
expand to<.) (.note that (csright<cs) and (csbiggr<cs) are
being unnaturally applied to a naturally open-type delimiter<.)
(literal
( -> \delimiter"4... \after@open
\left( ->
  \@@left \delimiter"4... \after@open
\right( ->
  \@@right \delimiter"4... \after@close
\biggl( ->
  \mathopen{\@@left \delimiter... \vrule...\@@right.}
  \after@open
\biggr( ->
  \mathclose{\@@left \delimiter... \vrule...\@@right.}
  \after@close
\bigg\vert ->
  \mathord{\@@left \delimiter... \vrule...\@@right.}
\biggm\vert ->
  \mathrel{\@@left \delimiter... \vrule...\@@right.}
<literal)
<para)

(para(.first save the primitive meanings of (csleft<cs) and
(csright<cs)<.)
(code
\@saveprimitive\left\@@left
\@saveprimitive\right\@@right
<code)
<para)

(para(.the variable (cslr@level<cs) is used by the first mathrel in
an equation to tell whether it is at top level: yes? break and measure
the LHS, no? keep going<.)
(code
\newcount\lr@level
<code)
<para)

(para(.it would be nice to have better error checking here if the
argument is not a delimiter symbol at all<.)
(code
\def\eq@left{%
  \@ifnext .{\eq@nullleft}{\begingroup \let\delimiter\eq@left@a}%
}
\def\eq@right{%
  \@ifnext .{\eq@nullright}{\begingroup \let\delimiter\eq@right@a}%
}
<code)
(.the arguments are: [arg1] delim symbol, [arg2]<.)
(code
\def\eq@left@a#1 #2{\endgroup\@@left\delimiter#1 \after@open}
\def\eq@right@a#1 #2{\endgroup
  \@@right\delimiter#1 \after@close\ss@scan{#1}%
}
<code)
(.the null versions<.)
(code
\def\eq@nullleft#1{\@@left#1\after@open}
\def\eq@nullright#1{\@@right#1\after@close}
<code)
<para)

(para(.here is the normal operation of (csbiggl<cs), for example<.)
(literal
\biggl ->\mathopen \bigg
{\mathopen}

\bigg #1->{\hbox {$\left #1\vbox to14.5\p@ {}\right .\n@space $}}
#1<-(
<literal)
(|For paren matching: )<|)
(.like (csleft<cs), (csbiggl<cs) coerces its delimiter to be of
mathopen type even if its natural inclination is towards closing<.)
<para)
(para(.the function (csdelim@reset<cs) makes delimiter characters
work just about the same as they would in normal [latex]<.)
(code
\def\delim@reset{%
  \let\after@open\relax \let\after@close\relax
  \let\left\@@left \let\right\@@right
}
<code)
(.if the (pkgamsmath<pkg) or (pkgexscale<pkg) package is loaded, it
will have defined (csbBigg@<cs); if not, the macros (csbig<cs) and
variants will have hard-coded point sizes as inherited through the ages
from (fnplain.tex<fn)<.) (.in this case we can kluge a little by
setting (csbig@size<cs) to (csp@<cs), so that our definition of
(csbBigg@<cs) will work equally well with the different multipliers<.)
(code
\@ifundefined{bBigg@}{% not defined
  \let\big@size\p@
  \def\big{\bBigg@{8.5}}\def\Big{\bBigg@{11.5}}%
  \def\bigg{\bBigg@{14.5}}\def\Bigg{\bBigg@{17.5}}%
  \def\biggg{\bBigg@{20.5}}\def\Biggg{\bBigg@{23.5}}%
}{}
\def\bBigg@#1#2{%
  {\delim@reset
   \left#2%
   \vrule\@height#1\big@size\@width-\nulldelimiterspace
   \right.
  }%
}
<code)
(.<.)
(code
\def\bigl#1{\mathopen\big{#1}\after@open}
\def\Bigl#1{\mathopen\Big{#1}\after@open}
\def\biggl#1{\mathopen\bigg{#1}\after@open}
\def\Biggl#1{\mathopen\Bigg{#1}\after@open}
\def\bigggl#1{\mathopen\biggg{#1}\after@open}
\def\Bigggl#1{\mathopen\Biggg{#1}\after@open}

\def\bigr#1{\mathclose\big{#1}\after@close}
\def\Bigr#1{\mathclose\Big{#1}\after@close}
\def\biggr#1{\mathclose\bigg{#1}\after@close}
\def\Biggr#1{\mathclose\Bigg{#1}\after@close}
\def\bigggr#1{\mathclose\biggg{#1}\after@close}
\def\Bigggr#1{\mathclose\Biggg{#1}\after@close}

%% No change needed, I think. [mjd,1998/12/04]
%%\def\bigm{\mathrel\big}
%%\def\Bigm{\mathrel\Big}
%%\def\biggm{\mathrel\bigg}
%%\def\Biggm{\mathrel\Bigg}
%%\def\bigggm{\mathrel\biggg}
%%\def\Bigggm{\mathrel\Biggg}
<code)
<para)

(define(macrom@@DeL<macro) (macrod@@DeL<macro)
(macrom@@DeR<macro) (macrod@@DeR<macro)
(macrom@@DeB<macro) (macrod@@DeB<macro)
(para(.original definition of (csm@DeL<cs) from
(pkgflexisym<pkg) is as follows<.) (.(csm@DeR<cs) and
(csm@DeB<cs) are the same except for the math class number<.)
(literal
\def\m@DeL#1#2#3{%
  \delimiter"4\@xp\delim@a\csname sd@#1#2#3\endcsname #1#2#3 }
<literal)
<para)
(para(.save the existing meanings of (csm@De[LRB]<cs)<.)
(code
\let\m@@DeL\m@DeL \let\m@@DeR\m@DeR \let\m@@DeB\m@DeB
\def\d@@DeL#1#2#3{%
  \delimiter"4\@xp\delim@a\csname sd@#1#2#3\endcsname #1#2#3 \after@open
}
\def\d@@DeR#1#2#3{%
  \delimiter"5\@xp\delim@a\csname sd@#1#2#3\endcsname #1#2#3 \after@close
}
\def\d@@DeB#1#2#3{%
  \delimiter"0\@xp\delim@a\csname sd@#1#2#3\endcsname #1#2#3 \after@bidir
}
<code)
<para)
<define)
(define(macroafter@open<macro)
(macroafter@close<macro)
(macroafter@bidir<macro)
(macrozero@bop<macro)
(macrobop@incr<macro)
(para(.(csafter@open<cs) and (csafter@close<cs) are carefully
written to avoid the use of grouping and to run as fast as possible<.)
(.(cszero@bop<cs) is the value used for (csprebinoppenalty<cs) at
delimiter level 0, while (csbop@incr<cs) is added for each level of
nesting<.) (.the standard values provide that breaks will be prohibited
within delimiters below nesting level 2<.)
(code
\let\after@bidir\@empty
\mathchardef\zero@bop=888 \relax
\mathchardef\bop@incr=4444 \relax
\def\after@open{%
  \global\advance\lr@level\@ne
  \prebinoppenalty\bop@incr \multiply\prebinoppenalty\lr@level
  \advance\prebinoppenalty\zero@bop
  \ifnum\eqbreakdepth<\lr@level
    \let\m@Bin\m@@Bin
<code)
(.inside delimiters, add some fillglue before binops so that a broken off
portion will get thrown flush right<.) (.also shift it slightly
further to the right to ensure that it clears the opening delimiter<.)
(code
  \else
    \eq@binoffset=\eqbinoffset
    \advance\eq@binoffset\lr@level\eqdelimoffset plus1fill\relax
    \def\dt@fill@cancel{\hskip\z@ minus1fill\relax}%
  \fi
}
\def\after@close{%
  \global\advance\lr@level\m@ne
  \prebinoppenalty\bop@incr \multiply\prebinoppenalty\lr@level
  \advance\prebinoppenalty\zero@bop
  \ifnum\eqbreakdepth<\lr@level
  \else \let\m@Bin\d@@Bin
  \fi
<code)
(.when we get back to level 0, no delimiters, remove the stretch
component of (cseqbinoffset<cs)<.)
(code
  \ifnum\lr@level<\@ne \eq@binoffset=\eqbinoffset\relax \fi
}
<code)
<para)
<define)

(define(macrosubsup@flag<macro)
(macross@scan<macro)
(para(.(csss@scan<cs) is called after a (csright<cs) delimiter and
looks ahead for sub and superscript tokens<.)
(.if sub and/or superscripts are present, we adjust the line-ending
penalty to distinguish the various cases (psub, sup, or both<p)<.)
(.this facilitates the later work of excising the sub/sup box and
reattaching it with proper shifting<.)
(code
\let\subsup@flag=\count@
\def\ss@delim@a#1#2#3#4{\xdef\right@delim@code{\number"#2#3#4}}
<code)
(.the argument of (csss@scan<cs) is an expanded form of a
right-delimiter macro<.)
(.we want to use the last three digits in the expansion
to define (csright@delim@code<cs)<.)
(.the assignment to a temp register is just a way to scan away the
leading digits that we don't care about<.)
(code
\def\ss@scan#1{%
<code)
(.this part of the code<.)
(code
  \begingroup
    \let\delim@a\ss@delim@a \@tempcnta#1\relax
  \endgroup
  \subsup@flag\@M \afterassignment\ss@scan@a \let\@let@token=}
\def\ss@scan@a{%
  \ifx\@let@token\sb \advance\subsup@flag\@ne\else
  \ifx\@let@token\sp \advance\subsup@flag\tw@\else
    \ss@finish
    \expandafter\@firstoftwo % gobble \ss@scan@b
  \fi\fi
  \ss@scan@b\@let@token
}
<code)

(code
\def\ss@scan@b#1#2{#1{%
% hack! coff!
  \let\m@Bin\m@@Bin  \let\m@Rel\m@@Rel
  #2}\afterassignment\ss@scan@a \let\@let@token=}%
<code)
(.we need to keep following glue from disappearing
[mdash] [eg], a thickmuskip or medmuskip from a following mathrel or
mathbin symbol<.)
(code
\def\ss@finish{%
  \@@vadjust{\penalty\thr@@}%
  \penalty\right@delim@code \penalty-\subsup@flag \keep@glue
}
<code)
<para)<define)

(define(macroeq@lrunpack<macro)
(para(.for (cseq@lrunpack<cs) we need to break open a left-right box and
reset it just in case it contains any more special breaks<.) (.after
it is unpacked the recursion of (cseq@repack<cs) will continue,
acting on the newly created lines<.)
(code
\def\eq@lrunpack{\setbox\z@\lastbox
<code)
(.we remove the preceding glue item and deactivate
baselineskip for the next line, otherwise we would end up with
three items of glue (pcounting parskip<p) at this point instead of
the single one expected by our recursive repacking
procedure<.)
(code
  \unskip \nointerlineskip
<code)
(.then we open box 0, take the left-right box at the right end of
it, and break that open<.) (.if the line-ending penalty is greater than
10000, it means a sub and/or superscript is present on the right
delimiter and the box containing them must be taken off first<.)
(code
  \noindent\unhbox\z@ \unskip
  \subsup@flag-\lastpenalty \unpenalty
  \xdef\right@delim@code{\number\lastpenalty}%
  \unpenalty
  \ifnum\subsup@flag>\@M
    \advance\subsup@flag-\@M
    \setbox\tw@\lastbox
  \else \setbox\tw@\box\voidb@x
  \fi
  \setbox\z@\lastbox
  \ifvoid\tw@ \unhbox\z@
  \else \lrss@reattach % uses \subsup@flag, box\z@, box\tw@
  \fi
<code)
(.the reason for adding a null last line here is that the last
line will contain parfillskip in addition to rightskip, and a final
penalty of (m10000<m) instead of (m-1000N<m)
(p(m1[leq]N[leq]9<m)<p), which would interfere with the usual
processing<.) (.setting a null last line and discarding it dodges
this complication<.) (.the penalty value (m-10001<m) is a no-op case
in the case statement of (cseq@repacka<cs)<.)
(code
  \penalty-\@Mi\z@rule\@@par
  \setbox\z@\lastbox \unskip\unpenalty
%%{\showboxbreadth\maxdimen\showboxdepth99\showlists}%
}
<code)
<para)<define)

(define(macrolrss@reattach<macro)
(para
(.well, for a small self-contained computation, carefully
hand-allocated dimens should be safe enough<.) (!but let the
maintainer beware<!) (.this code cannot be arbitrarily transplanted
or shaken up without regard to grouping and interaction with other
hand-allocated dimens<.)
(code
\dimendef\sub@depth=8 \dimendef\sup@base=6
\dimendef\prelim@sub@depth=4 \dimendef\prelim@sup@base=2
\def\sym@xheight{\fontdimen5\textfont\tw@}
\def\sup@base@one{\fontdimen13\textfont\tw@}
\def\sub@base@one{\fontdimen16\textfont\tw@}
\def\sub@base@two{\fontdimen17\textfont\tw@}
<code)
(.note that only (cssup@drop<cs) and (cssub@drop<cs) come from
the next smaller math style<.)
(code
\def\sup@drop{\fontdimen18\scriptfont\tw@}
\def\sub@drop{\fontdimen19\scriptfont\tw@}
<code)
(.provide a mnemonic name for the math axis fontdimen, if it's not
already defined<.)
(code
\providecommand{\mathaxis}{\fontdimen22\textfont\tw@}
<code)
<para)
(para(.assumes box 2 contains the sub/sup and box 0 contains the left-right
box<.) (.this is just a repeat of the algorithm in (fntex.web<fn),
with some modest simplifications from knowing that this is only going to
be called at top level in a displayed equation, thus always mathstyle =
uncramped displaystyle<.)
(code
\def\lrss@reattach{%
  \begingroup
  % "The TeXbook" Appendix G step 18:
  \prelim@sup@base\ht\z@ \advance\prelim@sup@base-\sup@drop
  \prelim@sub@depth\dp\z@ \advance\prelim@sub@depth\sub@drop
  \unhbox\z@
  \ifcase\subsup@flag      % case 0: this can't happen
  \or \lr@subscript   % case 1: subscript only
  \or \lr@superscript % case 2: superscript only
  \else \lr@subsup    % case 3: sub and superscript both
  \fi
  \endgroup
}
<code)
(code
\def\lr@subscript{%
  \sub@depth\sub@base@one
  \ifdim\prelim@sub@depth>\sub@depth \sub@depth\prelim@sub@depth\fi
  \dim@a\ht\tw@ \advance\dim@a -.8\sym@xheight
  \ifdim\dim@a>\sub@depth \sub@depth\dim@a \fi
  \twang@adjust\sub@depth
  \lower\sub@depth\box\tw@
}
<code)

(code
\def\lr@superscript{%
  \sup@base\sup@base@one
  \ifdim\prelim@sup@base>\sup@base \sup@base\prelim@sup@base\fi
  \dim@a\dp\tw@ \advance\dim@a -.25\sym@xheight
  \ifdim\dim@a>\sup@base \sup@base\dim@a \fi
  \twang@adjust\sup@base
  \raise\sup@base\box\tw@
}
<code)

(code
\def\lr@subsup{%
  \sub@depth\sub@base@two
  \ifdim\prelim@sub@depth>\sub@depth \sub@depth\prelim@sub@depth \fi
  \twang@adjust\sub@depth
  \lower\sub@depth\box\tw@
}
<code)
<para)
(para(.for delimiters that curve top and bottom, the twang factor allows
horizontal shifting of the sub and superscripts so they don't
fall too far away (por too close for that matter<p)<.) (.this is
accomplished by arranging for (p[eg]<p) ("\right\rangle<") to leave
a penalty (mN<m) in the math list before the subsup penalty that triggers
(cslrss@reattach<cs), where (mN<m) is the mathcode of
(csrangle<cs) (pignoring (qqsmall<qq) variant<p)<.)
(code
\def\twang@adjust#1{%
  \begingroup
    \@ifundefined{twang@\right@delim@code}{}{%
      \dim@d=#1\advance\dim@d-\mathaxis
      % put an upper limit on the adjustment
      \ifdim\dim@d>1em \dim@d 1em \fi
      \kern\csname twang@\right@delim@code\endcsname\dim@d
    }%
  \endgroup
}
<code)
(.the method used to apply a (qqtwang<qq) adjustment is just an
approximate solution to a complicated problem<.)
(.we make the following assumptions that hold true, approximately,
for the most common kinds of delimiters:
(enumerate
(item
(.the right delimiter is symmetrical top to bottom<.)
<item)
(item(.there is an upper limit on the size of the adjustment<.)
<item)
(item(.when we have a superscript, the amount of left-skew that we
want to apply is linearly proportional to the distance of the bottom
left corner of the superscript from the math axis, with the ratio
depending on the shape of the delimiter symbol<.)
<item)
<enumerate)<.)
(.By symmetry, Assumption 3 is true also for subscripts (pupper left
corner<p)<.)
(.Assumption 2 is more obviously true for parens and braces, where the
largest super-extended versions consist of truly vertical parts with
slight bending on the ends, than it is for a (csrangle<cs)<.)
(.but suppose for the sake of expediency that it is
approximately true for rangle symbols also<.)
<para)
(para
(.here are some passable twang factors for the most common types of
delimiters in (fncmex10<fn), as determined by rough measurements from
magnified printouts<.)
(literal
  vert bar, double vert:  0
         square bracket: -.1
            curly brace: -.25
            parenthesis: -.33
                 rangle: -.4
<literal)
(.let's provide a non-private command for changing the twang factor of
a given symbol<.)
(code
\newcommand{\DeclareTwang}[2]{%
  \ifcat.\@nx#1\begingroup
    \lccode`\~=`#1\lowercase{\endgroup \DeclareTwang{~}}{#2}%
  \else
    \@xp\decl@twang#1?\@nil{#2}%
  \fi
}
<code)
(.note that this is dependent on a fixed interpretation of the
mathgroup number [arg4]<.)
(code
\def\decl@twang#1#2#3#4#5#6#7\@nil#8{%
  \@namedef{twang@\number"#4#5#6}{#8}%
}
\DeclareTwang{\rangle}{-.4}
\DeclareTwang{)}{-.33}
\DeclareTwang{\rbrace}{-.25}
<code)
<para)
<define)
<section)

(section(titleseries of expressions<title)
(para(.the (envdseries<env) environment is for a display
containing a series of expressions of the form (qA, B<q) or (qA and
B<q) or (qA, B, and C<q) and so on<.) (.typically the expressions
are separated by a double quad of space<.) (.if the expressions in a
series don't all fit in a single line, they are continued onto extra
lines in a ragged-center format<.)
(code
\newenvironment{dseries}{\@eq@numbertrue \@optarg\@dseries{}}{}%
\def\enddseries#1{\check@punct@or@qed}
\def\@dseries[#1]{%
<code)
(.turn off the special breaking behavior of mathrels [etc] for math
formulas embedded in a (envdseries<env) environment<.)
(code
  \def\display@setup{\displaystyle}%
  \let\eq@centerlines\@True
  \@dmath[#1]%
  \mathsurround\z@\@@math \penalty\@Mi
  \let\endmath\ends@math
  \def\premath{%
    \ifdim\lastskip<.49em \unskip\fi
    \ifnum\lastpenalty<\@M\dquad\fi
  }%
  \def\postmath{\eq@addpunct \penalty-99 \dquad \@ignoretrue }%
}
\def\end@dseries{%
  \unskip\unpenalty
  \@@endmath \mathsurround\z@ \end@dmath
}
<code)
<para)
(para(.and the unnumbered version of same<.)
(code
\newenvironment{dseries*}{\@eq@numberfalse \@optarg\@dseries{}}{}
\@namedef{enddseries*}#1{\check@punct@or@qed}
\@namedef{end@dseries*}{\end@dseries}
<code)
<para)
(para(.change the (envmath<env) environment to add
(cspremath<cs) and (cspostmath<cs)<.) (.they are no-ops except
inside a (envdseries<env) environment<.)
(code
\renewenvironment{math}{%
  \leavevmode \premath
  \ifmmode\@badmath\else\@@math\fi
}{%
  \ifmmode\@@endmath\else\@badmath\fi
}
\def\ends@math#1{\check@punct@or@qed}
\def\end@math{%
  \ifmmode\@@endmath\else\@badmath\fi
  \postmath
}
\newcommand\dquad{\hskip1em minus.25em }
\newcommand\premath{}\newcommand\postmath{}
<code)
<para)
<section)

(section(titleequation groups<title)
(para(.for many equation groups the strategy is easy: just center each
equation individually following the normal rules for a single
equation<.) (.in some groups, each equation gets its own number; in
others, a single number applies to the whole group (pand may need to be
vertically centered on the height of the group<p)<.) (.in still other
groups, the equations share a parent number but get individual equation
numbers consisting of parent number plus a letter<.)
<para)
(para(.if the main relation symbols in a group of equations are to be
aligned, then the final alignment computations cannot be done until the
end of the group [mdash] [ie], the horizontal positioning of the first
(mn - 1<m) equations cannot be done immediately<.) (.yet because of
the automatic line breaking, we cannot calculate an initial value of
RHS-max over the whole group unless we do a trial run on each equation
first to find an RHS-max for that equation<.) (.once we know RHS-group-max
and LHS-group-max we must redo the trial set of each equation because
they may affect the line breaks<.) (.if the second trial for an
equation fails (pone of its lines exceeds the available width<p), but
the first one succeeded, fall back to the first trial, [ie] let that
equation fall out of alignment with the rest of the group<.)
<para)
(para
(.all right then, here is the general idea of the whole algorithm for
group alignment<.)
(.to start with, ignore the possibility of equation numbers so that
our equation group has the form:
(literal
LHS[1] RHS[1,1] RHS[1,2] ... RHS[1,n[1]]
LHS[2] RHS[2,1] RHS[2,2] ... RHS[2,n[2]]
  ...
LHS[3] RHS[3,1] RHS[3,2] ... RHS[3,n[3]]
<literal)
<.)
(.the number of RHS's might not be the same for all of the
equations<.)
(.first, accumulate all of the equation contents in a queue, checking
along the way to find the maximum width of all the LHS's and the maximum
width of all the RHS's<.)
(.call these widths maxwd_L and maxwd_R<.)
(.clearly if maxwd_L + maxwd_R is less than or equal to the available
equation width then aligning all of the equations is going to be simple<.)
<para)
(para
(.otherwise we are going to have to break at least one of the RHS's
and/or at least one of the LHS's<.)
(.the first thing to try is using maxwd_L for the LHS's and breaking
all the RHS's as needed to fit in the remaining space<.)
(.however, this might be a really dumb strategy if one or more of the
LHS's is extraordinarily wide<.)
(.so before trying that we check whether maxwd_L exceeds some
threshold width beyond which it would be unsensible not to break the LHS<.)
(.such as, max(pone-third of the available width; six ems<p), or
something like that<.)
(?or how about this<?)
(.compare the average LHS width and RHS width and divide up the available
width in the same ratio for line breaking purposes<.)
<para)

(define(macroeq@group<macro)
(macroGRP@top<macro)
(para
(code
\let\eq@group\@False
\global\let\GRP@top\@True
<code)
<para)
<define)

(para(.definition of the (envdgroup<env) environment<.)
(code
\newenvironment{dgroup}{%
  \@eq@numbertrue \@optarg\@dgroup{}%
}{%
  \end@dgroup{\grp@resetnumber}%
}
<code)
(.and the<.)
(code
\newtoks\GRP@queue
\newenvironment{dgroup*}{%
  \@eq@numberfalse \@optarg\@dgroup{}%
}{
  \end@dgroup{}%
}
\def\@dgroup[#1]{%
  \let\eq@group\@True \global\let\GRP@top\@True
  \global\GRP@queue\@emptytoks \global\setbox\GRP@box\box\voidb@x
  \global\let\GRP@label\@empty
  \gdef\GRP@info{\grp@wdL\z@ \grp@wdT\z@ \grp@linewidth\z@}%
  \eq@prelim
  \setkeys{breqn}{#1}%
  \if@eq@number \grp@setnumber \fi
}
\def\end@dgroup#1{%
  \EQ@displayinfo \grp@finish
  #1% \grp@resetnumber
}
<code)
(.if the (pkgamsmath<pkg) package is not loaded the parentequation
counter will not be defined<.)
(code
\@ifundefined{c@parentequation}{\newcounter{parentequation}}{}
<code)
(.init<.)
(code
\global\let\GRP@label\@empty
\def\add@grp@label{%
  \ifx\@empty\GRP@label
  \else \GRP@label \global\let\GRP@label\@empty
  \fi
}
<code)
(.before sending down the `equation' counter to the subordinate level,
set the current number in (csEQ@numbox<cs)<.) (.the
(cseq@setnumber<cs) function does everything we need here<.) (.if
the child equations are unnumbered, (csEQ@numbox<cs) will retain the
group number at the end of the group<.)
(code
\def\grp@setnumber{%
  \global\let\GRP@label\next@label \global\let\next@label\@empty
  \eq@setnumber
<code)
(.define (cntheparentequation<cn) equivalent to current
(cntheequation<cn)<.) (.(cnedef<cn) is necessary to expand the
current value of the equation counter<.) (.this might in rare cases
cause something to blow up, in which case the user needs to add
(cnprotect<cn)<.)
(code
  \protected@edef\theparentequation{\theequation}%
  \setcounter{parentequation}{\value{equation}}%
<code)
(.and set the equation counter to 0, so that the normal incrementing
processes will produce the desired results if the child equations are
numbered<.)
(code
  \setcounter{equation}{0}%
  \def\theequation{\theparentequation\alph{equation}}%
}
<code)
(.at the end of a group, need to reset the equation counter<.)
(code
\def\grp@resetnumber{%
  \setcounter{equation}{\value{parentequation}}%
}
<code)
<para)

(define(macroGRP@info<macro)
(para
(code
\gdef\GRP@info{\grp@wdL\z@ \grp@wdT\z@ \grp@linewidth\z@}
<code)
<para)
<define)

(define(macroGRP@box<macro)
(para
(code
\newbox\GRP@box
<code)
<para)
<define)

(define(macrogrp@push<macro)
(para
(.for putting the equation on a queue<.)
(code
\def\grp@push{%
  \global\GRP@queue\@xp\@xp\@xp{\@xp\the\@xp\GRP@queue
    \@xp\@elt\@xp{\EQ@trial}%
  }%
  \global\setbox\GRP@box\vbox{%
    \hbox{\box\EQ@box\box\EQ@copy\penalty\@ne\copy\EQ@numbox}%
    \unvbox\GRP@box
  }%
  \EQ@trial \GRP@info
  \xdef\GRP@info{%
    \grp@wdL=\ifdim\eq@wdL>\grp@wdL \the\eq@wdL \else \the\grp@wdL \fi
    \grp@wdT=\ifdim\eq@wdT>\grp@wdT \the\eq@wdT \else \the\grp@wdT \fi
    \grp@linewidth=%
      \ifdim\eq@linewidth>\grp@linewidth \the\eq@linewidth
      \else \the\grp@linewidth
      \fi
    \relax
  }%
}
<code)
<para)
<define)

(define(macrogrp@finish<macro)
(para
(.set accumulated equations from a (envdgroup<env) environment<.)
(code
\def\grp@finish{%
\debug@box\GRP@box
%\debugmsg{\GRP@queue: \the\GRP@queue}%
  \GRP@info
<code)
(.first accumulate the max RHS width in (csgrp@wdT<cs), then add
(csgrp@wdL<cs) to it afterwards<.)
(code
  \grp@wdL\z@ \grp@wdT\z@
  \let\@elt\eqgrp@prelim
  \the\GRP@queue
  \advance\grp@wdT\grp@wdL
\debugmsg{grp@wdL \the\grp@wdL, grp@wdT \the\grp@wdT}%
  \let\@elt\eqgrp@elt
  \the\GRP@queue
  \let\@elt\relax
  \eq@botspace
}
<code)
<para)
<define)

(define(macroeqgrp@prelim<macro)
(para
(.measure the bits and pieces<.)
(code
\def\eqgrp@prelim#1{%
  #1%
  \ifdim\eq@wdL>\grp@wdL \grp@wdL\eq@wdL \fi
  \dim@a\eq@wdT \advance\dim@a-\eq@wdL
  \ifdim\dim@a>\grp@wdT \grp@wdT\dim@a \fi
}
<code)
<para)
<define)

(define(macroeqgrp@elt<macro)
(para
(.mission is to typeset the next equation from the group queue<.)
(code
\def\eqgrp@elt#1{%
  \global\setbox\GRP@box\vbox{%
    \unvbox\GRP@box
    \setbox\z@\lastbox
    \setbox\tw@\hbox{\unhbox\z@
      \ifnum\lastpenalty=\@ne
      \else
        \global\setbox\EQ@numbox\lastbox
      \fi
      \unpenalty
      \global\setbox\EQ@copy\lastbox
      \global\setbox\EQ@box\lastbox
    }%
  }%
  \begingroup \let\eq@botspace\relax
  #1%
  \eq@finish
  \endgroup
}
<code)
<para)
<define)
<section)

(section(titlethe (envdarray<env) environment<title)
(para(.there are two potential applications for darray<.) (.one
is like eqnarray where the natural structure of the material crosses the
table cell boundaries, and math operator spacing needs to be preserved
across cell boundaries<.) (.and there is also the feature of
attaching an equation number to each row<.) (.the other application
is like a regular array but with automatic displaystyle math in each
cell and better interline spacing to accommodate outsize cell
contents<.) (.in this case it is difficult to keep the vert ruling
capabilities of the standard (envarray<env) environment without
redoing the implementation along the lines of Arseneau's
(pkgtabls<pkg) package<.) (.because the vert ruling feature is at
cross purposes with the feature of allowing interline stretch and page
breaks within a multiline array of equations, the (envdarray<env)
environment is targeted primarily as an alternative to
(enveqnarray<env), and does not support vertical ruling<.)
<para)
(para(.overall strategy for (envdarray<env) is to use
(cshalign<cs) for the body<.) (!in the case of a group, use a
single halign for the whole group<!)
(aside(?what about intertext<?)<aside)
(.that's the most reliable way
to get accurate column widths<.) (.don't spread the halign to the
column width, just use the natural width<.) (!then, if we repack the
contents of the halign into (csEQ@box<cs) and (csEQ@copy<cs), as
done for dmath, and twiddle a bit with the widths of the first and last
cell in each row, we can use the same algorithms for centering and
equation number placement as dmath<!) (.as well as handling footnotes
and vadjust objects the same way<.)
<para)
(para(.we can't just use (csarraycolsep<cs) for (envdarray<env), if
we want to be able to change it without screwing up interior arrays<.)
(.so let's make a new colsep variable<.) (.the initial value is
(q2em, but let it shrink if necessary<q)<.)
(code
\newskip\darraycolsep \darraycolsep 20pt plus1fil minus12pt
<code)
(.let's make a nice big default setup with eighteen columns, split up
into six sets of lcr like (enveqnarray<env)<.)
(code
\newcount\cur@row \newcount\cur@col
\def\@tempa#1#2#3{%
  \cur@col#1 \hfil
  \setbox\z@\hbox{$\displaystyle####\m@th$}\@nx\col@box
  \tabskip\z@skip
  &\cur@col#2 \hfil
  \setbox\z@\hbox{$\displaystyle\mathord{}####\mathord{}\m@th$}\@nx\col@box
  \hfil
  &\cur@col#3 \setbox\z@\hbox{$\displaystyle####\m@th$}\@nx\col@box
  \hfil\tabskip\darraycolsep
}
\xdef\darray@preamble{%
  \@tempa 123&\@tempa 456&\@tempa 789%
  &\@tempa{10}{11}{12}&\@tempa{13}{14}{15}&\@tempa{16}{17}{18}%
  \cr
}
\@ifundefined{Mathstrut@}{\let\Mathstrut@\strut}{}
\def\darray@cr{\Mathstrut@\cr}
\def\col@box{%
%\debugmsg{Col \number\cur@row,\number\cur@col: \the\wd\z@\space x \the\ht\z@+\the\dp\z@}%
  \unhbox\z@
}
\newenvironment{darray}{\@optarg\@darray{}}{}
\def\@darray[#1]{%
  \if\eq@group\else\eq@prelim\fi
<code)
(.init the halign preamble to empty, then unless the (qcols<q) key is
used to provide a non-null preamble just use the
default darray preamble which is a multiple lcr<.)
(code
  \global\let\@preamble\@empty
  \setkeys{breqn}{#1}%
  \the\eqstyle \eq@setnumber
  \ifx\@preamble\@empty \global\let\@preamble\darray@preamble \fi
  \check@mathfonts
  % \let\check@mathfonts\relax % tempting, but too risky
  \@xp\let\csname\string\ \endcsname\darray@cr
  \setbox\z@\vbox\bgroup
  \everycr{\noalign{\global\advance\cur@row\@ne}}%
  \tabskip\z@skip \cur@col\z@
  \global\cur@row\z@
  \penalty\@ne % flag for \dar@repack
  \halign\@xp\bgroup\@preamble
}
<code)
(.assimilate following punctuation<.)
(code
\def\enddarray#1{\check@punct@or@qed}
\def\end@darray{%
  \ifvmode\else \eq@addpunct \Mathstrut@\fi\crcr \egroup
  \dar@capture
  \egroup
}
<code)
<para)
(para(.the (csdar@capture<cs) function steps back through the
list of row boxes and grinds them up in the best possible way<.)
(code
\def\dar@capture{%
%% \showboxbreadth\maxdimen\showboxdepth99\showlists
  \eq@wdL\z@ \eq@wdRmax\z@ \eq@sidespace\maxdimen
  \dar@repack
}
<code)
<para)
(para(.the (csdar@repack<cs) function is a variation of
(cseq@repack<cs)<.)
(code
\def\dar@repack{%
  \unpenalty
  \setbox\tw@\lastbox
%\batchmode{\showboxbreadth\maxdimen\showboxdepth99\showbox\tw@}\errorstopmode
  \global\setbox\EQ@box\hbox{%
    \hbox{\unhcopy\tw@\unskip}\penalty-\@M \unhbox\EQ@box}%
  \global\setbox\EQ@copy\hbox{%
    \hbox{\unhbox\tw@\unskip}\penalty-\@M \unhbox\EQ@copy}%
  \unskip
  \ifcase\lastpenalty \else\@xp\@gobble\fi
  \dar@repack
}
<code)
<para)
<section)

(section(titlemiscellaneous<title)
(para(.the (cscondition<cs) command<.) (.with
the star form, set the argument in math mode instead of text mode<.)
(.in a series of conditions, use less space between members of the
series than between the conditions and the main equation body<.)
(code
\newskip\conditionsep \conditionsep=10pt minus5pt%
\newcommand{\conditionpunct}{,}
\let\cond@gobble\@firstofone
\newcommand\condition{%
  \begingroup\@tempswatrue
    \@ifstar{\@tempswafalse \condition@a}\condition@a
}
\newcommand\condition@a[2][\conditionpunct]{%
  \hbox{#1}\hskip\conditionsep
  \if@tempswa \@xp\hbox \else \@xp\condition@b\fi
  {#2}%
  \endgroup
  \let\cond@gobble\@gobble
}
<code)
(.for a math condition<.)
(.this is called inside a group so we don't need extra grouping to
localize the effect of (cstextmath@setup<cs) which turns off the
line-breaking features of bin, rel, and delimiter symbols<.)
(code
\newcommand\condition@b[1]{%
  \cond@gobble{\hskip\conditionsep}%
  \textmath@setup #1%
}
<code)
<para)
(para(.the (envdsuspend<env) environment<.)
(code
\newenvironment{dsuspend}{%
  \global\setbox\EQ@box\vbox\bgroup \@parboxrestore
<code)
(.if we are inside a list environment, (csdisplayindent<cs) and
(csdisplaywidth<cs) give us (cs@totalleftmargin<cs) and
(cslinewidth<cs)<.)
(code
    \parshape 1 \displayindent \displaywidth\relax
    \hsize=\columnwidth \noindent\ignorespaces
}{%
  \par\egroup
<code)
(.let's try giving (csEQ@box<cs) the correct height for the first
line and (csEQ@copy<cs) the depth of the last line<.)
(code
  \global\setbox\GRP@box\vbox{%
    \vbox{\copy\EQ@box\vtop{\unvbox\EQ@box}}%
    \unvbox\GRP@box
  }%
<code)
(.need to add a dummy element to (csGRP@queue<cs)<.)
(code
  \global\GRP@queue\@xp{\the\GRP@queue
    \@elt{\gdef\EQ@trial{}}%
  }%
}
<code)
(.allow (cnintertext<cn) as a short form of the (envdsuspend<env)
environment; it's more convenient to write, but it doesn't support
embedded verbatim because it reads the material as a macro argument<.)
(.to support simultaneous use of (pkgamsmath<pkg) and
(pkgbreqn<pkg), the user command (csintertext<cs) is left alone
until we enter a (pkgbreqn<pkg) environment<.)
(code
\newcommand\breqn@intertext[1]{\dsuspend#1\enddsuspend}
<code)
<para)

(define(macro*<macro)
(macrodiscretionarytimes<macro)
(para(.discretionary times sign<.) (.standard [latex] definition
serves only for inline math<.) (?should the thin space be
included<?) (.not sure<.)
(code
\renewcommand{\*}{%
  \if@display
<code)
(.since (cseq@binoffset<cs) is mu-glue, we can't use it directly
with (cskern<cs) but have to measure it separately in a box<.)
(code
    \setbox\z@\hbox{\mathsurround\z@$\mkern\eq@binoffset$}%
    \discretionary{}{%
      \kern\the\wd\z@ \textchar\discretionarytimes
    }{}%
    \thinspace
  \else
    \discretionary{\thinspace\textchar\discretionarytimes}{}{}%
  \fi
}
<code)
(.this is only the symbol; it can be changed to some other symbol if
desired<.)
(code
\newcommand{\discretionarytimes}{\times}
<code)
<para)<define)

(define(macronref<macro)
(para
(.this is like (csref<cs) but doesn't apply font changes or other
guff if the reference is undefined<.)
(.and it is fully expandable for use as a label value<.)
(aside
(.can break with Babel if author uses active characters in label key;
need to address that (dnmjd,1999/01/21<dn)<.)<aside)
(code
\def\nref#1{\@xp\@nref\csname r@#1\endcsname}
\def\@nref#1#2{\ifx\relax#1??\else \@xp\@firstoftwo#1\fi}
<code)
<para)
<define)

<section)

(section(titlewrap-up<title)
(para(.the usual endinput<.)
(code
\endinput %
<code)
<para)
<section)

(section(titleto do<title)
(para(enumerate
(item(.alignment for equation groups<.)
<item)
(item
(.use dpc's code for package options in keyval form<.)<item)
(item
(.encapsulate (qqbreak math<qq) into a subroutine taking suitable
arguments<.)<item)
(item
(.need a density check for layout S when linewidth is very small<.)<item)
(item
(.Make (":=<") trigger a warning about using (cscoloneq<cs)
instead<.)<item)
(item(.ill-centered multiline equation (pthree-line case<p) in
test008<.)<item)
(item(.attaching a single group number<.)
<item)
(item
(.make sure to dump out box registers after done using them<.)<item)
(item(.do the implementation for (cseq@resume@parshape<cs)<.)
<item)
(item(.check on stackrel and buildrel and relbar and ???<.)
<item)
(item(.test math symbols at the beginning of array cells<.)<item)
(item(.test [dbslash] cmd in and out of delims<.)<item)
(item(.framing the equation body: the parshape and number placement
need adjusting when a frame is present<.)
<item)
(item(.cascading line widths in list env<.)
<item)
(item(?noalign option for dmath = multline arrangement<?)
<item)
(item(.nocompact option, suggested 1998/05/19 by Andrew
Swann<.)
<item)
(item(.(csdelbreak<cs) cmd to add discretionary space at a break
within delimiters<.)
<item)
(item(.reduce above/below skip when the number is shifted<.)
<item)
(item(.need a (csmiddelim<cs) command for marking a delimiter symbol
as nondirectional if it has an innate directionality ("()[]<") [etc]<.)
<item)
(item
(.(csxrightarrow<cs) from amsmath won't participate in line
breaking unless something extra is done<.)
(?make (csBreakingRel<cs) and (csBreakingBin<cs) functions<?)<item)
(item(.placement of number in an indented quotation or
abstract<.)<item)
(item(.if (mLHSwd > 2em<m), it might be a good idea to try with
eq@indentstep = 2em before shifting the number<.) (.currently this
doesn't happen if the first trial pass (pwithout the number<p)
succeeds with (mindentstep = LHSwd > 2em<m)<.)
<item)
(item(?read past ("\end{enumerate}<") when checking
for ("\end{proof}<")<?)<item)
(item
(.look into using a (qqqed-list<qq) of environment names instead of
checking the existence of (csproofqed<cs)<.)<item)
(item(.pick up the vadjust[slash]footnote[slash]mark handling<.)
<item)
(item(.forcing[slash]prohibiting page breaks after[slash]before
an equation<.)
<item)
(item(.adding a spanner brace on the left and individual numbers on
the right (pindy-numbered cases<p)<.)
<item)
(item(.provide (csshiftnumber<cs), (csholdnumber<cs) to
override the decision<.)<item)
(item (.provide a mechanism for adjusting the vertical position of
the number<.) (.here a version-specific selection macro would be
useful<.)
(literal
\begin{dmath}[
  style={\foredition{1}{\raisenumber{13pt}}}
]
<literal)
<item)
(item
(.add an alignleft option for an equation group to mean, break and
align to a ladder layout as usual within the equations, but for the
group alignment used the leftmost point (pfor equations that don't
have an LHS, this makes no difference<p)<.)<item)
(item
(.test with Arseneau's wrapfig for parshape[slash]everypar
interaction<.)
<item)
(item(.fix up the macro/def elements<.)<item)
(item(.convert the literal examples in section (qEquation types and
forms<q) to typeset form<.)
<item)
(item(.compile comparison-examples: [eg], a standard equation
env with big left-right objects that don't shrink, versus how shrinking
can allow it to fit<.)
<item)
(item(.frame the (qqfigures<qq) since they are mostly
text<.)<item)
<enumerate)
<para)
(para
(.possible enhancements:
(enumerate
(item(.provide a (optpull<opt) option meaning to pull the first
and last lines out to the margin, like the (envmultline<env)
environment of the (pkgamsmath<pkg) package<.) (.maybe this should
get an optional argument, actually, to specify the amount of space left
at the margin<.)<item)
(item(.with the draft option, one would like to see the equation
labels in the left margin<.) (.need to check with the
(pkgshowkeys<pkg) package<.)
<item)
(item(.options for break preferences: if there's not enough room, do
we first shift the number, or first try to break up the equation
body?<.) (.in an aligned group, does sticking to the group alignment
take precedence over minimizing the number of line breaks needed for
individual equations?<.) (.and the general preferences probably need
to be overridable for individual instances<.)<item)
(item(.extend suppress-breaks-inside-delimiters support to inline
math (psuggestion of Michael Doob<p)<.)<item)
(item(.use belowdisplayshortskip above a dsuspend fragment if the
fragment is only one line and short enough compared to the equation line
above it<.)
<item)
(item(.add (cseqfuzz<cs) distinct from (cshfuzz<cs)<.)
(.make use of it in the measuring phase<.)
<item)
(item(.provision for putting in a (qcontinued<q) note<.)<item)
(item(.conserve box mem: modify frac, sub, sup, overline, underline,
sqrt, to turn off (csbin@break<cs) and (pless urgently<p)
(csrel@break<cs)<.)
<item)
(item(.more explicit support for Russian typesetting conventions (pcf
Grinchuk article<p)<.)
<item)
(item(.with package option (optrefnumbers<opt),
leave unnumbered all uncited equations, even if they are not done with
the star form (pBertolazzi's easyeqn idea<p)<.)<item)
(item(.in an equation group, use a vertical bracket with the
equation number to mark the lines contained in that equation<.)
<item)
(item(.for a two-line multline thingamabob, try to
make sure that the lines overlap in the middle by 2 em or whatever
(psettable design variable<p)<.)<item)
(item(.provide a separate vertical column for the principal mathrel
symbols and center them within the column if they aren't all the same
width<.) (.maybe an option for (envdmath<env): relwidth=x, so that two
passes are not required to get the max width of all the mathrels<.)
(.or, no, just require it to be an halign or provide a macro to be
applied to all the shorter rels:
(literal
lhs \widerel{19pt}{=} ...
    \xrightarrow{foo} ...
<literal)
<.)
<item)
(itemtry to use vadjust for keepglue<item)
<enumerate)<.)
<para)<section)
<document)
